config:
  entries: 1024
  entry_len: 16
  #  per_chunk_cycles: true
  auto: { min: 0x300, max: 0x3ff }
constants:
  ADD_CC:  szhvn0c     # ADD,ADC
  SUB_CC:  szhvn1c     # CP, NEG, SBC, SUB
  SH_CC:   szh0vn0c    # RL,RLC,RR,RRC,SLA,SLL,SRA,SRL
  INC_CC:  szhvn0      # INC
  DEC_CC:  szhvn1      # CPD,CPDR,CPI,CPIR,DEC
  AND_CC:  szh1pn0c0   # AND,
  OR_CC:   szh0pn0c0   # OR,XOR
  BIT_CC:  zch1n0      # BIT
  TSET_CC: zhn         # TSET
ops:
  # Group 1: destination is R, source is either r or memory
  # examples ADC R,r   CP R,(mem)
  # First byte contains either r or (mem). Second byte is OP and R. Same OP for both addressing modes
  # bit 3 set in OP makes (mem) the destination: OR (mem),R
  # R,r register in lower 3 bits  11zz'1rrr
  - { name: rzzB,  op: 0x0c8, mask: 0x3f8, ctl: { setw: b }, cycles: 1 }
  - { name: rzzW,  op: 0x0d8, mask: 0x3f8, ctl: { setw: w }, cycles: 1 }
  - { name: rzzQ,  op: 0x0e8, mask: 0x3f8, ctl: { setw: q }, cycles: 1 }
  # R,r register in next byte
  - { name: frzzB, op: 0x0c7,              ctl: { setw: b }, cycles: 1 }
  - { name: frzzW, op: 0x0d7,              ctl: { setw: w }, cycles: 1 }
  - { name: frzzQ, op: 0x0e7,              ctl: { setw: q }, cycles: 1 }

  # Group 2 R,(mem) and (mem),R
  # R,(mem). Page 43 of 900H CPU Book
  - { name: mem_reg,  op: 0x080, mask: 0x3f8, ctl: { setw: b }, cycles: 3 }
  - { name: mem_reg,  op: 0x090, mask: 0x3f8, ctl: { setw: w }, cycles: 3 }
  - { name: mem_reg,  op: 0x0a0, mask: 0x3f8, ctl: { setw: q }, cycles: 5 }
  - { name: mem_reg8, op: 0x088, mask: 0x3f8, ctl: { setw: b, d8: 1 }, cycles: 3 }
  - { name: mem_reg8, op: 0x098, mask: 0x3f8, ctl: { setw: w, d8: 1 }, cycles: 3 }
  - { name: mem_reg8, op: 0x0a8, mask: 0x3f8, ctl: { setw: q, d8: 1 }, cycles: 5 }

  - { name: mem_da,   op: 0x0c0, ctl: { setw: b } }  # -1--'000? (#8)
  - { name: mem_da,   op: 0x0d0, ctl: { setw: w } }
  - { name: mem_da,   op: 0x0e0, ctl: { setw: q } }
  - { name: mem_da,   op: 0x0c1, ctl: { setw: b, off16: 1 } }  # -1--'000? (#16)
  - { name: mem_da,   op: 0x0d1, ctl: { setw: w, off16: 1 } }
  - { name: mem_da,   op: 0x0e1, ctl: { setw: q, off16: 1 } }
  - { name: mem_da24, op: 0x0c2, ctl: { setw: b } }  # -1--'0010 (#24)
  - { name: mem_da24, op: 0x0d2, ctl: { setw: w } }  # -1--'0010 (#24)
  - { name: mem_da24, op: 0x0e2, ctl: { setw: q } }  # -1--'0010 (#24)
  - { name: mem, op: 0x0c3, mask: 0x3ff, ctl: { setw: b } }  # -1--'0011 (r32)
  - { name: mem, op: 0x0d3, mask: 0x3ff, ctl: { setw: w } }
  - { name: mem, op: 0x0e3, mask: 0x3ff, ctl: { setw: q } }
  - { name: mem, op: 0x0c4, mask: 0x3ff, ctl: { setw: b } }  # -1--'0100 (-r32)
  - { name: mem, op: 0x0d4, mask: 0x3ff, ctl: { setw: w } }
  - { name: mem, op: 0x0e4, mask: 0x3ff, ctl: { setw: q } }
  - { name: mem, op: 0x0c5, mask: 0x3ff, ctl: { setw: b } }  # -1--'0100 (r32+)
  - { name: mem, op: 0x0d5, mask: 0x3ff, ctl: { setw: w } }
  - { name: mem, op: 0x0e5, mask: 0x3ff, ctl: { setw: q } }

  # Group 3 #3,(mem) 1m11'mmmm
  - { name: mem,  op: 0x0b0, mask: 0x3f0, ctl: { setw: w        } }
  - { name: mem,  op: 0x0f0, mask: 0x3fc, ctl: {                } } # f0~f3
  - { name: mem,  op: 0x0f4, mask: 0x3fe, ctl: {                } } # f4~f5

  ########### instructions ###################

  # group 0 instructions
  - { name: DECF,   op: 0x00d, ctl: { alu: ADD } }
  - { name: EI,     op: 0x006                } # also serves as DI when operand is 7
  - { name: EXFF,   op: 0x016                } # EX F,F'
  - { name: HALT,   op: 0x005                }
  - { name: INCF,   op: 0x00c, ctl: { alu: SUB } }
  - { name: JP,     op: 0x01a, ctl: { srca: imm,   setw: w } } # JP #16
  - { name: JP,     op: 0x01b, ctl: { srca: imm24, setw: q } } # JP #24
  - { name: JR,     op: 0x060, mask: 0x3f0 } # JR [cc,]
  - { name: JRL,    op: 0x070, mask: 0x3f0 } # JRL [cc,]
  - { name: LD8,    op: 0x008, ctl: { setw: b } } # LD<B> (#8),#
  - { name: LD8,    op: 0x00a, ctl: { setw: w } } # LD<W> (#8),#
  - { name: LD,     op: 0x020, mask: 0x3f8, ctl: { srca: imm, setw: b } } # LD R,# zzz encoding
  - { name: LD,     op: 0x030, mask: 0x3f8, ctl: { srca: imm, setw: w } } # LD R,# zzz encoding
  - { name: LD,     op: 0x040, mask: 0x3f8, ctl: { srca: imm, setw: q } } # LD R,# zzz encoding
  - { name: LDF,    op: 0x017 }
  - { name: LDX,    op: 0x0f7 }
  - { name: CALL16, op: 0x01c, ctl: { setw: w } }
  - { name: CALL24, op: 0x01d, ctl: { setw: q, call24: 1 } } # only 24 bits read
  - { name: CALR,   op: 0x01e }
  - { name: CCF,    op: 0x012, ctl: { carry: com, cc: n0c } }
  - { name: NOP,    op: 0x000 }
  - { name: PUSHA,  op: 0x014 }
  - { name: POPA,   op: 0x015, ctl: { dst: acc, setw: b }}
  - { name: PUSHF,  op: 0x018, ctl: { dst: f  , setw: b }}
  - { name: POPF,   op: 0x019 }
  - { name: POP,    op: 0x048, ctl: { setw: w }, mask: 0x3f8 } # POP R
  - { name: POP,    op: 0x058, ctl: { setw: q }, mask: 0x3f8 } # POP R
  - { name: PUSH,   op: 0x028, ctl: { setw: w }, mask: 0x3f8 } # PUSH R
  - { name: PUSH,   op: 0x038, ctl: { setw: q }, mask: 0x3f8 } # PUSH R
  - { name: PUSH,   op: 0x009, ctl: { setw: b } }
  - { name: PUSH,   op: 0x00b, ctl: { setw: w } }
  - { name: PUSH,   op: 0x002, ctl: { setw: w } } # PUSH SR
  - { name: POPSR,  op: 0x003, ctl: { dst: sr, setw: w, carry: hi } } # POP SR
  - { name: RCF,    op: 0x010, ctl: { cc: h0n0c0 } }
  - { name: RET,    op: 0x00e }
  - { name: RETD,   op: 0x00f }
  - { name: RETI,   op: 0x007 }
  - { name: SCF,    op: 0x011, ctl: { carry: hi, cc: h0n0c } }
  - { name: SWI,    op: 0x0f8, mask: 0x3f8 }
  - { name: ZCF,    op: 0x013, ctl: { carry: zf, cc: n0c } }

  # group 1 instructions, R,r
  - { name: ADC,   op: 0x190, ctl: { alu: ADD, carry: cin, srca: reg, ld: dst, cc: "${ADD_CC}" }, mask: 0x3f8, cycles: 1 }
  - { name: ADD,   op: 0x180, ctl: { alu: ADD,             srca: reg, ld: dst, cc: "${ADD_CC}" }, mask: 0x3f8, cycles: 1 }
  - { name: AND,   op: 0x1c0, ctl: { alu: AND,             srca: reg, ld: dst, cc: "${AND_CC}" }, mask: 0x3f8 }
  - { name: CP,    op: 0x1f0, ctl: { alu: SUB,             srca: reg,          cc: "${SUB_CC}" }, mask: 0x3f8 }
  - { name: DIV,   op: 0x150, ctl: { cc: v },                                                     mask: 0x3f8 } # only byte/word
  - { name: DIVS,  op: 0x158, ctl: { cc: v },                                                     mask: 0x3f8 } # only byte/word
  - { name: EX,    op: 0x1b8, mask: 0x3f8 } # EX R,r
  - { name: LD,    op: 0x188, ctl: { srca: reg,         ld: dst }, mask: 0x3f8 } # LD R,r
  - { name: LD,    op: 0x198, ctl: { srca: reg, swp: 1, ld: dst }, mask: 0x3f8 } # LD r,R
  - { name: MULA,  op: 0x119, ctl: { cc: szv } }
  - { name: MUL,   op: 0x140,                                                         mask: 0x3f8 } # only byte/word
  - { name: MULS,  op: 0x148,                                                         mask: 0x3f8 } # only byte/word
  - { name: OR,    op: 0x1e0, ctl: { alu: OR, cc: "${OR_CC}" },                       mask: 0x3f8 }
  - { name: SBC,   op: 0x1b0, ctl: { cc: "${SUB_CC}" },                               mask: 0x3f8, cycles: 1 }
  - { name: SUB,   op: 0x1a0, ctl: { cc: "${SUB_CC}" },                               mask: 0x3f8, cycles: 1 }
  - { name: XOR,   op: 0x1d0, ctl: { alu: XOR, cc: "${OR_CC}" },                      mask: 0x3f8, cycles: 1 }
  # group 1 - r
  - { name: ANDCF,  op: 0x128, ctl: { alu: BAND, srca: acc, carry: cin, cc: c } }
  - { name: BS1B,   op: 0x10f, ctl: {             cc: z2v } }
  - { name: BS1F,   op: 0x10e, ctl: { alu: MIRR , cc: z2v } }
  - { name: DAA,    op: 0x110, ctl: {             cc: szhvcr } }
  - { name: DEC,    op: 0x168, ctl: { alu: SUB, srca: num3, ld: dst, cc: "${DEC_CC}" }, mask: 0x3f8 } # DEC #3,r
  - { name: DJNZ,   op: 0x11c }
  - { name: EXTS,   op: 0x113, ctl: { ext: sex } }
  - { name: EXTZ,   op: 0x112, ctl: { ext: zex } }
  - { name: INC,    op: 0x160, ctl: { alu: ADD, srca: num3, cc: "${INC_CC}" }, mask: 0x3f8 } # INC #3,r
  - { name: LDC,    op: 0x12e } # LDC cr,r
  - { name: LDC,    op: 0x12f } # LDC r,cr
  - { name: LDCF,   op: 0x12b, ctl: { alu: BOR, srca: acc,             cc: c }} # register A always used
  - { name: ORCF,   op: 0x129, ctl: { alu: BOR, srca: acc, carry: cin, cc: c }} # register A always used
  - { name: PAA,    op: 0x114 } # PAA r
  - { name: POPr2,  op: 0x105 } # POP r
  - { name: PUSHr2, op: 0x104 } # PUSH r
  - { name: XORCF,  op: 0x12A, ctl: { alu: BXOR, srca: acc, carry: cin, cc: c }} # register A always used
  # group 1 with immediate data ADC r,#
  - { name: ADC,   op: 0x1c9, ctl: { alu: ADD, carry: cin, srca: imm, ld: dst, cc: "${ADD_CC}" } }
  - { name: ADD,   op: 0x1c8, ctl: { alu: ADD,             srca: imm, ld: dst, cc: "${ADD_CC}" } }
  - { name: AND,   op: 0x1cc, ctl: { alu: AND,             srca: imm, ld: dst, cc: "${AND_CC}" } }
  - { name: CP,    op: 0x1cf, ctl: { alu: SUB, srca: imm,  cc: "${SUB_CC}" } }
  - { name: CP,    op: 0x1d8, ctl: { alu: SUB, srca: num3, cc: "${SUB_CC}" }, mask: 0x3f8 }
  - { name: DIV,   op: 0x10a, ctl: { cc: v } }
  - { name: DIVS,  op: 0x10b, ctl: { cc: v } }
  - { name: LD,    op: 0x103, ctl: { srca: imm,  ld: dst } } # LD r,#
  - { name: LD,    op: 0x1a8, ctl: { srca: num3, ld: dst }, mask: 0x3f8 } # LD r,#3
  - { name: MUL,   op: 0x108 }
  - { name: MULS,  op: 0x109 }
  - { name: OR,    op: 0x1ce, ctl: { alu: OR,  srca: imm, cc: "${OR_CC}"  } }
  - { name: SBC,   op: 0x1cb, ctl: { alu: SUB, srca: imm, cc: "${SUB_CC}" } }
  - { name: SUB,   op: 0x1ca, ctl: { alu: SUB, srca: imm, cc: "${SUB_CC}" } }
  - { name: XOR,   op: 0x1cd, ctl: { alu: XOR, srca: imm, cc: "${OR_CC}"  } }
  # group 1 but limited valid addressing
  - { name: CPL,   op: 0x106, ctl: { alu: CPL, ld: dst, cc: h1n1 } } # only byte/word
  - { name: LINK,  op: 0x10c                } # only long word
  - { name: MDEC1, op: 0x13c, ctl: { rmux: one,  alu: sub }} # only word
  - { name: MDEC2, op: 0x13d, ctl: { rmux: two,  alu: sub }} # only word
  - { name: MDEC4, op: 0x13e, ctl: { rmux: four, alu: sub }} # only word
  - { name: MINC1, op: 0x138, ctl: { rmux: one,  alu: add }} # only word
  - { name: MINC2, op: 0x139, ctl: { rmux: two,  alu: add }} # only word
  - { name: MINC4, op: 0x13a, ctl: { rmux: four, alu: add }} # only word
  - { name: MIRR,  op: 0x116, ctl: { alu: MIRR, ld: dst } } # only byte
  - { name: NEG,   op: 0x107, ctl: { cc: "${SUB_CC}" }} # only byte/word
  - { name: RLA,   op: 0x1fa, ctl: { alu: SHL, srca: acc, cc: "${SH_CC}", cx: cin }} # register A always used RL  A,r
  - { name: RRA,   op: 0x1fb, ctl: { alu: SHR, srca: acc, cc: "${SH_CC}", cx: cin }} # register A always used RR  A,r
  - { name: RLCA,  op: 0x1f8, ctl: { alu: SHL, srca: acc, cc: "${SH_CC}", cx: sa  }} # register A always used RRC A,r
  - { name: RRCA,  op: 0x1f9, ctl: { alu: SHR, srca: acc, cc: "${SH_CC}", cx: sh  }} # register A always used RRC A,r
  - { name: SCC,   op: 0x170, mask: 0x3f0 } # SCC cc,r cc = #4
  - { name: SLAA,  op: 0x1fc, ctl: { cc: "${SH_CC}"  }, opmask: 0x3fd } # register A always used SLL A,r SLA=SLL
  - { name: SRAA,  op: 0x1fd, ctl: { cc: "${SH_CC}"  }} # register A always used SRA A,r
  - { name: SRLA,  op: 0x1ff, ctl: { cc: "${SH_CC}"  }} # register A always used SRL A,r
  - { name: STCFA, op: 0x12c                } # register A always used STCF A,r
  - { name: UNLK,  op: 0x10d                } # first byte always 0xe8 & 0xf8
  # #4,r
  - { name: ANDCF, op: 0x120, ctl: { alu: BAND, srca: num4, carry: cin, cc: c }}
  - { name: BIT,   op: 0x133, ctl: { alu: BXOR, srca: num4, carry: hi, cc: "${BIT_CC}" }}
  - { name: CHG,   op: 0x132, ctl: { alu: BXOR, srca: num4, carry: hi } }
  - { name: LDCF,  op: 0x123, ctl: { alu: BOR,  srca: num4,             cc: c }}
  - { name: ORCF,  op: 0x121, ctl: { alu: BOR,  srca: num4, carry: cin, cc: c }}
  - { name: XORCF, op: 0x122, ctl: { alu: BXOR, srca: num4, carry: cin, cc: c }}
  - { name: RES,   op: 0x130 }
  - { name: RL,    op: 0x1ea, ctl: { alu: SHL, srca: num4, cc: "${SH_CC}", cx: cin }}
  - { name: RLC,   op: 0x1e8, ctl: { alu: SHL, srca: num4, cc: "${SH_CC}", cx: sa  }}
  - { name: RR,    op: 0x1eb, ctl: { alu: SHR, srca: num4, cc: "${SH_CC}", cx: cin }}
  - { name: RRC,   op: 0x1e9, ctl: { alu: SHR, srca: num4, cc: "${SH_CC}", cx: sh  }}
  - { name: SET,   op: 0x131 }
  - { name: SLA,   op: 0x1ec, ctl: { alu: SHL, srca: num4, cc: "${SH_CC}" }, opmask: 0x3fd } # SLA=SLL
  - { name: SRA,   op: 0x1ed, ctl: { alu: SHR, srca: num4, cc: "${SH_CC}",  cx: sa }}
  - { name: SRL,   op: 0x1ef, ctl: { alu: SHR, srca: num4, cc: "${SH_CC}"          }}
  - { name: STCF,  op: 0x124 }
  - { name: TSET,  op: 0x134, ctl: { cc: "${TSET_CC}" } }

  # group 2 - R,(mem) - (mem),R
  - { name: ADC,   op: 0x290, ctl: { alu: ADD, carry: cin, srca: rmem, ld: dst, cc: "${ADD_CC}" }, mask: 0x3f8, cycles: 1 }
  - { name: ADCM,  op: 0x298, ctl: { alu: ADD, carry: cin, srca: memr,          cc: "${ADD_CC}" }, mask: 0x3f8, cycles: 1 }
  - { name: ADD,   op: 0x280, ctl: { alu: ADD,             srca: rmem, ld: dst, cc: "${ADD_CC}" }, mask: 0x3f8, cycles: 1 }
  - { name: ADDM,  op: 0x288, ctl: { alu: ADD,             srca: rmem,          cc: "${ADD_CC}" }, mask: 0x3f8, cycles: 1 }
  - { name: AND,   op: 0x2c0, ctl: { alu: AND,             srca: rmem, ld: dst, cc: "${AND_CC}" }, mask: 0x3f8 }
  - { name: ANDM,  op: 0x2c8, ctl: { alu: AND,             srca: memr,          cc: "${AND_CC}" }, mask: 0x3f8 }
  - { name: CP,    op: 0x2f0, ctl: { alu: SUB,             srca: rmem,          cc: "${SUB_CC}" }, mask: 0x3f8 }
  - { name: CPM,   op: 0x2f8, ctl: { alu: SUB,             srca: memr,          cc: "${SUB_CC}" }, mask: 0x3f8 }
  - { name: EXM,   op: 0x230, mask: 0x3f8 }
  - { name: OR,    op: 0x2e0, ctl: { alu: OR,  cc: "${OR_CC}"  }, mask: 0x3f0 }
  - { name: SBC,   op: 0x2b0, ctl: { alu: SUB, cc: "${SUB_CC}", carry: cin }, mask: 0x3f0, cycles: 1 }
  - { name: SUB,   op: 0x2a0, ctl: { alu: SUB, cc: "${SUB_CC}"             }, mask: 0x3f0, cycles: 1 }
  - { name: XOR,   op: 0x2d0, ctl: { alu: XOR, cc: "${OR_CC}"  }, mask: 0x3f0, cycles: 1 }
  # group 2 - RR,(mem) bit 3 does not follow the same pattern as in R,(mem)-(mem),R
  - { name: DIV,   op: 0x250, ctl: { cc: v }, mask: 0x3f8 } # only byte/word
  - { name: DIVS,  op: 0x258, ctl: { cc: v }, mask: 0x3f8 } # only byte/word
  - { name: LD,    op: 0x220, ctl: { srca: rmem, ld: dst }, mask: 0x3f8 } # LD R,(mem)
  - { name: MUL,   op: 0x240, mask: 0x3f8 } # only byte/word
  - { name: MULS,  op: 0x248, mask: 0x3f8 } # only byte/word
  # group 2 - <W> (mem)
  - { name: ADCM,  op: 0x239, ctl: { alu: ADD, carry: cin, srca: imm, cc: "${ADD_CC}" }}
  - { name: ADDM,  op: 0x238, ctl: { alu: ADD,             srca: imm, cc: "${ADD_CC}" }}
  - { name: ANDM,  op: 0x23c, ctl: { alu: AND,             srca: imm, cc: "${AND_CC}" }}
  - { name: CPM,   op: 0x23f, ctl: { alu: SUB,             srca: imm, cc: "${SUB_CC}" }}
  - { name: DECM,  op: 0x268, ctl: { alu: SUB, srca: num3, cc: "${DEC_CC}" }, mask: 0x3f8 } # inc<w> #3,(mem)
  - { name: INCM,  op: 0x260, ctl: { alu: ADD, srca: num3, cc: "${INC_CC}" }, mask: 0x3f8 } # inc<w> #3,(mem)
  - { name: ORM,   op: 0x23e, ctl: { srca: imm, cc: "${OR_CC}" }}
  - { name: PUSHM, op: 0x204 }
  - { name: RLCM,  op: 0x278, ctl: { alu: SHL, cc: "${SH_CC}", cx: sa  }}
  - { name: RRCM,  op: 0x279, ctl: { alu: SHR, cc: "${SH_CC}", cx: sh  }}
  - { name: RLM,   op: 0x27a, ctl: { alu: SHL, cc: "${SH_CC}", cx: cin }}
  - { name: RRM,   op: 0x27b, ctl: { alu: SHR, cc: "${SH_CC}", cx: cin }}
  - { name: SBCM,  op: 0x23b, ctl: { alu: SUB, srca: imm, carry: cin, cc: "${SUB_CC}" }}
  - { name: SLAM,  op: 0x27c, opmask: 0x3fd } # SLA=SLM
  - { name: SRAM,  op: 0x27d }
  - { name: SRLM,  op: 0x27f }
  - { name: SUBM,  op: 0x23a, ctl: { alu: SUB, srca: imm, cc: "${SUB_CC}" }}
  - { name: XORM,  op: 0x23d, ctl: { alu: XOR, srca: imm, cc: "${OR_CC}"  }}
  # Group 2 - string instructions
  - { name: CPD,   op: 0x216, ctl: { loop: znvloop, cc: "${DEC_CC}" }}
  - { name: CPDR,  op: 0x217, ctl: { loop: znvloop, cc: "${DEC_CC}" }}
  - { name: CPI,   op: 0x214, ctl: { loop: znvloop, cc: "${DEC_CC}" }}
  - { name: CPIR,  op: 0x215, ctl: { loop: znvloop, cc: "${DEC_CC}" }}
  - { name: LDD,   op: 0x212, ctl: { cc: h0v3n0 }} # XDE,XHL or XIX,XIY is based on the first byte. v becomes ~z_out
  - { name: LDDR,  op: 0x213, ctl: { cc: h0n0v0 }} # XDE,XHL or XIX,XIY is based on the first byte
  - { name: LDI,   op: 0x210, ctl: { cc: h0v3n0 }} # XDE,XHL or XIX,XIY is based on the first byte
  - { name: LDIR,  op: 0x211, ctl: { cc: h0n0v0 }} # XDE,XHL or XIX,XIY is based on the first byte
  # group 2 1m00'mmmm limited byte size
  - { name: RLD,   op: 0x206, ctl: { cc: szh0vn0 }} # RRD [A,](mem)
  - { name: RRD,   op: 0x207, ctl: { cc: szh0vn0 }} # RRD [A,](mem)

  # group 3 1m11'mmmm
  - { name: RETcc, op: 0x3f0, ctl: { ncc: ncc }, mask: 0x3f0 } # B0-Fcc
  - { name: LDAR,  op: 0x313 }              # F3-13-#16-4R
  - { name: JPM,   op: 0x3d0, mask: 0x3f0 } # 1m11mmmm (possibly F3)-Dcc JP [cc,]mem
  - { name: LD,    op: 0x340, mask: 0x3c8 } # 1m11mmmm (possibly F3)-4R (mem),R
  - { name: LDM,   op: 0x300, ctl: { srca: imm, setw: b } } # (mem),#
  - { name: LDM,   op: 0x302, ctl: { srca: imm, setw: w } } # (mem),#
  - { name: LDM2DA,op: 0x319 } # (#16),(mem)
  - { name: LDDA2M,op: 0x314, mask: 0x3fd } # (mem),(#16)
  - { name: LDA,   op: 0x320, ctl: { setw: w }, mask: 0x3f8 }
  - { name: LDA,   op: 0x330, ctl: { setw: q }, mask: 0x3f8 }
  # group 3 1m11'mmmm #3,(mem)
  - { name: ANDCF, op: 0x380, ctl: { alu: BAND, carry: cin, srca: acc,  cc: c          }, mask: 0x3f8 }
  - { name: BIT,   op: 0x3c8, ctl: { alu: BXOR, carry: hi,  srca: num3, cc: "${BIT_CC}"}, mask: 0x3f8 }
  - { name: CALLcc,op: 0x3e0,                                                    mask: 0x3f0 }
  - { name: CHG,   op: 0x3c0, ctl: { alu: BXOR, srca: num3, carry: hi },         mask: 0x3f8 }
  - { name: LDCF,  op: 0x398, ctl: { alu: BOR,  srca: num3,             cc: c }, mask: 0x3f8 }
  - { name: ORCF,  op: 0x388, ctl: { alu: BOR,  srca: num3, carry: cin, cc: c }, mask: 0x3f8 }
  - { name: XORCF, op: 0x390, ctl: { alu: BXOR, srca: num3, carry: cin, cc: c }, mask: 0x3f8 }
  - { name: POPM,  op: 0x304, ctl: { setw: b } }
  - { name: POPM,  op: 0x306, ctl: { setw: w } }
  - { name: RES,   op: 0x3b0,                                                    mask: 0x3f8 }
  - { name: SET,   op: 0x3b8,                                                    mask: 0x3f8 }
  - { name: STCF,  op: 0x3a0,                                                    mask: 0x3f8 }
  - { name: TSET,  op: 0x3a8, ctl: { cc: "${TSET_CC}" },                         mask: 0x3f8 }
  # group 3 1m11'mmmm A,(mem)
  - { name: ANDCF, op: 0x328, ctl: { alu: BAND, carry: cin, srca: acc, cc: c }}
  - { name: LDCF,  op: 0x32b, ctl: { alu: BOR,  srca: acc, cc: c }}
  - { name: ORCF,  op: 0x329, ctl: { alu: BOR,  srca: acc, carry: cin, cc: c }}
  - { name: XORCF, op: 0x32a, ctl: { alu: BXOR, srca: acc, carry: cin, cc: c }}
  - { name: STCF,  op: 0x32c }

ucode:
  - name: da2ea2md
    auto: true
    seq:
      - da2ea # keep md (contains op)
      - m_ea
      - m_ea, q_fetch, waitmem # loads data in md
      - ld1_opnd # operand data in md
      - md_ld, swp_opnd # restores md to have op code, operand data in op0
      - g2_nxgr, ni
  - mnemo: [ mem_reg ] # (XWA), (XSP)... no indexing
    seq:
      - q_setw, dst_ral
      - dst_rmux, ld0_opnd, s8_fetch, inc_pc
      - da_ld, ld0_opnd, ${setw}_setw, da2ea2md_jsr
  - mnemo: [ mem_reg8 ] # (XWA+d8), 8-bit indexing
    seq:
      - q_setw, dst_ral, s8_fetch, inc_pc
      - dst_rmux, ld0_opnd, b_setw
      - sex, ld1_opnd, q_setw
      - add_alu, da_ld, ${setw}_setw, ld0_opnd, da2ea2md_jsr
  - mnemo: [ mem_da ]
    seq:
      - b_setw, s8_fetch, inc_pc    # #8 by default
      - ?${off16}, w_setw, inc_pc   # #16 if off16 is set
      - zex, ld0_opnd, q_setw
      - da_ld, ${setw}_setw, ld0_opnd, da2ea2md_jsr
  - mnemo: [ mem_da24 ]
    seq:
      - q_setw, s8_fetch, inc_pc
      - inc_pc
      - ld0_opnd, inc_pc
      - inc_pc
      - waitmem, q_fetch # need to fetch new data
      - da_ld, ${setw}_setw, ld0_opnd, da2ea2md_jsr

  # Load op1 operand (source)
  - name: reg
    auto: true
    seq:
      - s8_fetch, inc_pc
      - src_ral
      - ret_jsr, src_rmux, ld1_opnd
  - name: imm
    auto: true
    seq:
      - inc_pc, s8_fetch
      - retb, ld1_opnd # conditional return on byte size
      - inc_pc, retw   # conditional return on word size
      - inc_pc
      - inc_pc, ret_jsr
  - name: imm24
    auto: true
    seq:
      - inc_pc, s8_fetch
      - inc_pc
      - inc_pc, ret_jsr
  - name: acc
    auto: true
    seq:
      - a_rmux, ld1_opnd, ret_jsr
  - name: num4 # #4
    auto: true
    seq:
      - s8_fetch, inc_pc
      - n4_rmux, ld1_opnd, ret_jsr
  - name: num3 # #3
    auto: true
    seq:
      - n3_rmux, ld1_opnd, ret_jsr
  # R,(mem) (bit 3 clear) and (mem),R (bit 3 set)
  - name: rmem
    auto: true
    seq:
      - dst_ral
      - dst_rmux, ld1_opnd
      - inc_pc, swp_opnd
  - name: memr
    auto: true
    seq:
      - src_ral
      - src_rmux, ld1_opnd
      - inc_pc, swp_opnd
  - name: zni
    auto: true
    seq:
      - inc_pc
      -
      - waitmem, q_fetch
      - ni
  - name: ncc
    auto: true
    seq:
      - inc_pc
      -
      - waitmem, q_fetch
      - ni
  # Load op0 operand (destination)
  - mnemo: [ rzzB, rzzW, rzzQ ]
    seq:
      - ${setw}_setw, dst_ral, s8_fetch, inc_pc
      - g1_nxgr, ni, dst_rmux, ld0_opnd
  - mnemo: [ frzzB, frzzW, frzzQ ]
    seq:
      - ${setw}_setw, s8_fetch, inc_pc
      - full, dst_ral, s8_fetch, inc_pc
      - g1_nxgr, ni, dst_rmux, ld0_opnd
# instructions
  - mnemo: [ ADC, ADD, AND, ANDCF, CCF, CP, CPL, DEC, INC,
            MIRR, LD, LDCF, OR, ORCF, RCF, SUB, SBC, SCF, XOR, XORCF, ZCF ]
    seq:
      - ${srca}_jsr
      - ?${swp}, swp_opnd, swp_ral
      - ${alu}_alu, ${carry}_carry, ${ld}_ld, ${cc}_cc, inc_pc
      -
      - waitmem, q_fetch
      - ni
  # save to memory
  - mnemo: [ ADCM, ADDM, ANDM, CPM, DECM, INCM, ORM, SUBM, SBCM, XORM, LDM ]
    seq:
      - ${srca}_jsr
      - ${alu}_alu, ${carry}_carry, md_ld, ${cc}_cc
      - m_ea, wr, waitmem
      - inc_pc
      -
      - waitmem, q_fetch
      - ni
  # compare data and count up/down BC
  - mnemo: [ CPD, CPDR, CPI, CPIR ]
    seq:
      - acc_jsr
      - sub_alu, ${cc}_cc, inc_pc
      - bc_rmux, ld0_opnd
      - zero_rmux, ld1_opnd
      - ${alu}_alu, hi_carry, bc_ld, z3v_cc # v = ~z
      - ${loop}  # loops while z!=1 && v!=0
      - waitmem, q_fetch
      - ni
  - mnemo: [ DAA ]
    seq:
      - daa_alu, md_ld, inc_pc
      - ld1_opnd
      - add_alu, dst_ld, ${cc}_cc
      - waitmem, q_fetch
      - ni
  - mnemo: [ INCF, DECF ]
    seq:
      - rfp_rmux, ld0_opnd, inc_pc
      - zero_rmux, ld1_opnd
      - ${alu}_alu, hi_carry, rfp_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ EI ]
    seq:
      - s8_fetch, inc_pc
      - num3_jsr
      - iff_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ BS1F, BS1B ]
    seq:
      - ${alu}_alu, md_ld, inc_pc # for BS1F, this will mirror the operand
      - ld0_opnd
      - bs1b_alu, a_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ DJNZ ]
    seq:
      - s8_fetch, inc_pc                    # jump offset and PC adjustment
      - zero_rmux, ld1_opnd
      - sub_alu, hi_carry, dst_ld, zni_jsr  # conditionally end if ALU's z output was set
      - sex, ld0_opnd
      - pc_rmux, ld1_opnd
      - add_alu, pc_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ EX ]
    seq:
      - reg_jsr
      - swp_opnd
      - dst_ld, swp_ral
      - dst_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ EXFF ]
    seq:
      - exff, inc_pc
      - waitmem, q_fetch
      - ni
  - mnemo: [ EXM ]
    seq:
      - reg_jsr
      - swp_ral
      - swp_opnd, dst_ld
      - md_ld
      - m_ea, wr
      - m_ea, waitmem
      - waitmem, q_fetch
      - ni
  - mnemo: [ EXTS, EXTZ ]
    seq:
      - md_ld, inc_pc
      - ${ext}, ld0_opnd
      - dst_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ HALT ]
    seq:
      - inc_pc
      - halt
      - waitmem, q_fetch
      - ni
  - mnemo: [ JP ]
    seq:
      - ${srca}_jsr
      - md_rmux, ld0_opnd
      - pc_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ JPM ]
    seq:
      - s8_fetch, inc_pc
      - ncc_jsr             # finish if the cc condition is not met
      - ea_rmux, ld0_opnd
      - pc_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ LD8 ]  # LD<W> (#8),#
    seq:
      - s8_fetch, inc_pc      # load direct address from 8-bit immediate value
      - b_setw, ld0_opnd
      - da_ld
      - ${setw}_setw, imm_jsr
      - da_ea, wr
      - da_ea, waitmem
      - waitmem, q_fetch
      - ni
  - mnemo: [ LDM2DA ] # LD<W> (#16),(mem)
    seq:
      - swp_opnd              # moves MD from op0 to op1
      - s8_fetch, inc_pc      # load direct address from 16-bit immediate value
      - w_setw, ld0_opnd, inc_pc
      - da_ld
      - swp_opnd              # restores MD
      - da_ea, wr
      - da_ea, waitmem
      - waitmem, q_fetch
      - ni
  - mnemo: [ LDDA2M ] # LD<W> (mem),(#16)
    seq:
      - s8_fetch, inc_pc, swp_setw      # load direct address from 16-bit immediate value
      - w_setw, ld0_opnd, inc_pc
      - da_ld, swp_setw
      - da_ea
      - da_ea, waitmem, q_fetch
      - m_ea, wr
      - m_ea, waitmem
      -
      - waitmem, q_fetch
      - ni
  - mnemo: [ LDA ]
    seq:
      - ${setw}_setw, s8_fetch, inc_pc
      - ea_rmux, ld0_opnd, dst_ral
      - dst_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ MINC1, MINC2, MINC4, MDEC1, MDEC2, MDEC4 ]
    seq:
      - w_setw, imm_jsr         # op0 holds the register value
      - ${rmux}_rmux, ld1_opnd
      - ${alu}_alu, op2_ld      # op2 holds the modified LSB
      - md_rmux, ld1_opnd       # op1 holds the mask
      - mod_alu, dst_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ RET, RETD ]
    seq:
      - s8_fetch, inc_pc
      - ${ncc}_jsr, q_setw
      - xsp_rmux, ld0_opnd
      - da_ld, four_rmux, ld1_opnd
      - add_alu, xsp_ld
      - da_ea, waitmem, q_fetch
      - ld0_opnd
      - pc_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ CALL16, CALL24 ]
    seq:
      - s8_fetch, inc_pc, ${setw}_setw
      - xsp_rmux, ld0_opnd
      - four_rmux, ld1_opnd
      - sub_alu, xsp_ld       # XSP = XSP-4
      - zex, ld0_opnd, inc_pc
      - ?${call24}, inc_pc
      - md_ld, inc_pc       # zex-applied MD
      - md_rmux, ld1_opnd   # store it in op1
      - pc_rmux, ld0_opnd   # move PC to MD
      - md_ld, swp_opnd
      - sp_ea, wr           # push PC
      - sp_ea, waitmem
      - pc_ld               # PC gets the jump address
      - waitmem, q_fetch    # jump
      - ni
  - mnemo: [ CALR ]
    seq:
      - s8_fetch, inc_pc, q_setw
      - xsp_rmux, ld0_opnd
      - four_rmux, ld1_opnd
      - sub_alu, xsp_ld, w_setw # XSP = XSP-4
      - sex, ld0_opnd, inc_pc
      - md_ld, inc_pc       # sex-applied MD
      - md_rmux, ld1_opnd   # store it in op1
      - pc_rmux, ld0_opnd   # move PC to MD
      - md_ld
      - sp_ea, wr           # push PC
      - sp_ea, waitmem
      - add_alu, pc_ld      # jump address
      - waitmem, q_fetch    # jump
      - ni
  - mnemo: [ POPF, POPA, POPSR ]
    seq:
      - inc_pc, ${setw}_setw, one_rmux, ld1_opnd
      - sp_ea, waitmem, ${setw}_fetch
      - ld0_opnd
      - ${dst}_ld, xsp_rmux, ld0_opnd
      - add_alu, xsp_ld, ${carry}_carry
      - waitmem, q_fetch
      - ni
  - mnemo: [ SRA, SRL, RLC, RRC, RL, RR ]
    seq:
      - op2_ld                  # what to shift in op2
      - ${srca}_jsr             # times to shift in op1
      - sh4_alu,  md_ld         # times to shift adjusted in MD
      - ld1_opnd,               # times to shift adjusted in op1
      - one_rmux, ld0_opnd
      - ${alu}_alu,  ${cx}_carry, dst_ld, ${cc}_cc
      - ${alu}_alu,  ${cx}_carry, op2_ld
      - sub_alu, md_ld
      - sub_alu, ld1_opnd, zni_jsr # return if ALU's z is set
      - jb5                        # jumps back by 5
  - mnemo: [ RLCM, RRCM, RLM, RRM ]
    seq:
      - op2_ld, inc_pc
      - ${alu}_alu, ${cx}_carry, md_ld, ${cc}_cc
      - m_ea, wr
      - waitmem
      - waitmem, q_fetch
      - ni