config:
  entries: 1024
  entry_len: 16
  #  per_chunk_cycles: true
  auto: { min: 0x300, max: 0x3ff }
constants:
  ADD_CC:  szhvn0c     # ADD,ADC
  SUB_CC:  szhvn1c     # CP, NEG, SBC, SUB
  SH_CC:   szh0vn0c    # RL,RLC,RR,RRC,SLA,SLL,SRA,SRL
  INC_CC:  szhvn0      # INC
  DEC_CC:  szhvn1      # CPD,CPDR,CPI,CPIR,DEC
  AND_CC:  szh1pn0c0   # AND,
  OR_CC:   szh0pn0c0   # OR,XOR
  BIT_CC:  zch1n0      # BIT
  LD_CC:   h0v3n0      # LDD, LDDR, LDI, LDIR
# alias:
#   - &LOW3 0x3f8
ctrl:
  nxgr: { bw: 2, v: [ {g1: 1}, {g2: 2}, {g3: 3} ]}
ops:
  # Group 1: destination is R, source is either r or memory
  # examples ADC R,r   CP R,(mem)
  # First byte contains either r or (mem). Second byte is OP and R. Same OP for both addressing modes
  # bit 3 set in OP makes (mem) the destination: OR (mem),R
  # R,r register in lower 3 bits  11zz'1rrr
  - { name: rzzB,  op: 0x0c8, mask: 0x3f8, ctl: { setw: b }, cycles: 1 }
  - { name: rzzW,  op: 0x0d8, mask: 0x3f8, ctl: { setw: w }, cycles: 1 }
  - { name: rzzQ,  op: 0x0e8, mask: 0x3f8, ctl: { setw: q }, cycles: 1 }
  # R,r register in next byte
  - { name: frzzB, op: 0x0c7,              ctl: { setw: b }, cycles: 1 }
  - { name: frzzW, op: 0x0d7,              ctl: { setw: w }, cycles: 1 }
  - { name: frzzQ, op: 0x0e7,              ctl: { setw: q }, cycles: 1 }

  # Group 2 R,(mem) and (mem),R
  # R,(mem). Page 43 of 900H CPU Book
  - { name: mem_reg,  op: 0x080, mask: 0x3f8, ctl: { rd: 1, setw: b, d8: 0 }, cycles: 3 }
  - { name: mem_reg,  op: 0x090, mask: 0x3f8, ctl: { rd: 1, setw: w, d8: 0 }, cycles: 3 }
  - { name: mem_reg,  op: 0x0a0, mask: 0x3f8, ctl: { rd: 1, setw: q, d8: 0 }, cycles: 5 }
  - { name: mem_reg,  op: 0x088, mask: 0x3f8, ctl: { rd: 1, setw: b, d8: 1 }, cycles: 3 }
  - { name: mem_reg,  op: 0x098, mask: 0x3f8, ctl: { rd: 1, setw: w, d8: 1 }, cycles: 3 }
  - { name: mem_reg,  op: 0x0a8, mask: 0x3f8, ctl: { rd: 1, setw: q, d8: 1 }, cycles: 5 }

  - { name: mem_da,   op: 0x0c0, ctl: { rd: 1, setw: b, off16:   }}  # -1--'000? (#8)
  - { name: mem_da,   op: 0x0d0, ctl: { rd: 1, setw: w, off16:   }}
  - { name: mem_da,   op: 0x0e0, ctl: { rd: 1, setw: q, off16:   }}
  - { name: mem_da,   op: 0x0c1, ctl: { rd: 1, setw: b, off16: 1 }}  # -1--'000? (#16)
  - { name: mem_da,   op: 0x0d1, ctl: { rd: 1, setw: w, off16: 1 }}
  - { name: mem_da,   op: 0x0e1, ctl: { rd: 1, setw: q, off16: 1 }}
  - { name: mem_da24, op: 0x0c2, ctl: { rd: 1, setw: b }}  # -1--'0010 (#24)
  - { name: mem_da24, op: 0x0d2, ctl: { rd: 1, setw: w }}  # -1--'0010 (#24)
  - { name: mem_da24, op: 0x0e2, ctl: { rd: 1, setw: q }}  # -1--'0010 (#24)
  - { name: mem_r32,  op: 0x0c3, ctl: { rd: 1, setw: b }}  # -1--'0011 (r32)
  - { name: mem_r32,  op: 0x0d3, ctl: { rd: 1, setw: w }}
  - { name: mem_r32,  op: 0x0e3, ctl: { rd: 1, setw: q }}

  - { name: mem_iter, op: 0x0c4, ctl: { rd: 1, alu: SUB, setw: b, adr: SUB }}  # -1--'0100 (-r32)
  - { name: mem_iter, op: 0x0d4, ctl: { rd: 1, alu: SUB, setw: w, adr: SUB }}
  - { name: mem_iter, op: 0x0e4, ctl: { rd: 1, alu: SUB, setw: q, adr: SUB }}
  - { name: mem_iter, op: 0x0c5, ctl: { rd: 1, alu: ADD, setw: b, adr:     }}  # -1--'0100 (r32+)
  - { name: mem_iter, op: 0x0d5, ctl: { rd: 1, alu: ADD, setw: w, adr:     }}
  - { name: mem_iter, op: 0x0e5, ctl: { rd: 1, alu: ADD, setw: q, adr:     }}

  # Group 3 #3,(mem) 1m11'mmmm except RET cc and LDAR
  - { name: mem_reg,  op: 0x0b0, ctl: { rd: 0, setw: , d8: 0 }, mask: 0x3f8, cycles: 5 }
  - { name: mem_reg,  op: 0x0b8, ctl: { rd: 0, setw: , d8: 1 }, mask: 0x3f8, cycles: 3 }
  - { name: mem_da,   op: 0x0f0, ctl: { rd: 0, setw: , off16: 0 }}
  - { name: mem_da,   op: 0x0f1, ctl: { rd: 0, setw: , off16: 1 }}
  - { name: mem_da24, op: 0x0f2, ctl: { rd: 0, setw:            }}
  - { name: mem_r32,  op: 0x0f3, ctl: { rd: 0, setw:            }}
  - { name: mem_iter, op: 0x0f4, ctl: { rd: 0, alu: SUB, setw: , adr: SUB }}  # -1--'0100 (-r32)
  - { name: mem_iter, op: 0x0f5, ctl: { rd: 0, alu: ADD, setw: , adr:     }}  # -1--'0100 (r32+)


  ########### instructions ###################

  # group 0 instructions
  - { name: EXFF,   op: 0x016 } # EX F,F'
  - { name: HALT,   op: 0x005 }
  - { name: JP,     op: 0x01a, ctl: { srca: imm1,  setw: w }} # JP #16
  - { name: JP,     op: 0x01b, ctl: { srca: imm24, setw: q }} # JP #24
  - { name: JR,     op: 0x060, ctl: { setw: b, jr16:   }, mask: 0x3f0 } # JR [cc,]
  - { name: JR,     op: 0x070, ctl: { setw: w, jr16: 1 }, mask: 0x3f0 } # JRL [cc,]
  - { name: LD8,    op: 0x008, ctl: { setw: b }} # LD<B> (#8),#
  - { name: LD8,    op: 0x00a, ctl: { setw: w }} # LD<W> (#8),#
  - { name: LDX,    op: 0x0f7 }
  - { name: CALL16, op: 0x01c, ctl: { alu:    , ex: zex, setw: w, call24:   }}
  - { name: CALL24, op: 0x01d, ctl: { alu:    , ex: zex, setw: q, call24: 1 }} # only 24 bits read
  - { name: CALR,   op: 0x01e, ctl: { alu: add, ex: sex, setw: w, call24:   }}
  - { name: POPA,   op: 0x015, ctl: { dst:  a,  setw: b, wr: }}
  - { name: POPF,   op: 0x019, ctl: { dst: sr,  setw: b, wr: }}
  - { name: POP,    op: 0x048, ctl: { dst: dst, setw: w, wr: }, mask: 0x3f8 } # POP R
  - { name: POP,    op: 0x058, ctl: { dst: dst, setw: q, wr: }, mask: 0x3f8 } # POP R
  - { name: POPSR,  op: 0x003, ctl: { dst:  sr, setw: w, wr: }} # POP SR
  - { name: PUSHA,  op: 0x014, ctl: { pshr: 0, rmux: src, setw: b }}
  - { name: PUSHF,  op: 0x018, ctl: { pshr: 0, rmux: sr,  setw: b }}
  - { name: PUSHR,  op: 0x028, ctl: { pshr: 1, rmux: dst, setw: w }, mask: 0x3f8 } # PUSH R
  - { name: PUSHR,  op: 0x038, ctl: { pshr: 1, rmux: dst, setw: q }, mask: 0x3f8 } # PUSH R
  - { name: PUSHSR, op: 0x002, ctl: { pshr: 0, rmux: sr,  setw: w }} # PUSH SR
  - { name: PUSHW,  op: 0x009, ctl: { setw: b }}
  - { name: PUSHW,  op: 0x00b, ctl: { setw: w }}
  - { name: RET,    op: 0x00e, ctl: { retd: 0, ncc: }}
  - { name: RETD,   op: 0x00f, ctl: { retd: 1, ncc: }}
  - { name: RETI,   op: 0x007 }
  - { name: SWI,    op: 0x0f8, mask: 0x3f8 }

  # Solved in the main template
  - { name: ADC,   op: 0x190, ctl: { alu: ADD,  cx: cin, srca: reg,  ld: dst, setw: ,  wr:  , swp_opnd:  , swp_ral: $,cc: "${ADD_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,r
  - { name: ADC,   op: 0x1c9, ctl: { alu: ADD,  cx: cin, srca: imm1, ld: dst, setw: ,  wr:  , swp_opnd:  , swp_ral:  ,cc: "${ADD_CC}", ral:    }} # r,#
  - { name: ADC,   op: 0x239, ctl: { alu: ADD,  cx: cin, srca: imm0, ld: md,  setw: ,  wr: 1, swp_opnd:  , swp_ral:  ,cc: "${ADD_CC}", ral:    }} # <W> (mem),#
  - { name: ADC,   op: 0x290, ctl: { alu: ADD,  cx: cin, srca: rmem, ld: dst, setw: ,  wr:  , swp_opnd:  , swp_ral:  ,cc: "${ADD_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,(mem) / (mem),R
  - { name: ADC,   op: 0x298, ctl: { alu: ADD,  cx: cin, srca: rmem, ld: md,  setw: ,  wr: 1, swp_opnd:  , swp_ral:  ,cc: "${ADD_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,(mem) / (mem),R
  - { name: ADD,   op: 0x180, ctl: { alu: ADD,  cx:    , srca: reg,  ld: dst, setw: ,  wr:  , swp_opnd:  , swp_ral: $,cc: "${ADD_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,r
  - { name: ADD,   op: 0x1c8, ctl: { alu: ADD,  cx:    , srca: imm1, ld: dst, setw: ,  wr:  , swp_opnd:  , swp_ral:  ,cc: "${ADD_CC}", ral:    }} # r,#
  - { name: ADD,   op: 0x238, ctl: { alu: ADD,  cx:    , srca: imm0, ld: md,  setw: ,  wr: 1, swp_opnd:  , swp_ral:  ,cc: "${ADD_CC}", ral:    }} # <W> (mem),#
  - { name: ADD,   op: 0x280, ctl: { alu: ADD,  cx:    , srca: rmem, ld: dst, setw: ,  wr:  , swp_opnd:  , swp_ral:  ,cc: "${ADD_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,(mem) / (mem),R
  - { name: ADD,   op: 0x288, ctl: { alu: ADD,  cx:    , srca: rmem, ld: md,  setw: ,  wr: 1, swp_opnd:  , swp_ral:  ,cc: "${ADD_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,(mem) / (mem),R
  - { name: AND,   op: 0x1c0, ctl: { alu: AND,  cx:    , srca: reg,  ld: dst, setw: ,  wr:  , swp_opnd:  , swp_ral: $,cc: "${AND_CC}", ral:    }, mask: 0x3f8 }            # R,r
  - { name: AND,   op: 0x1cc, ctl: { alu: AND,  cx:    , srca: imm1, ld: dst, setw: ,  wr:  , swp_opnd:  , swp_ral:  ,cc: "${AND_CC}", ral:    }} # r,#
  - { name: AND,   op: 0x23c, ctl: { alu: AND,  cx:    , srca: imm0, ld: md,  setw: ,  wr: 1, swp_opnd:  , swp_ral:  ,cc: "${AND_CC}", ral:    }} # <W> (mem),#
  - { name: AND,   op: 0x2c0, ctl: { alu: AND,  cx:    , srca: rmem, ld: dst, setw: ,  wr:  , swp_opnd:  , swp_ral:  ,cc: "${AND_CC}", ral:    }, mask: 0x3f8 } # R,(mem) / (mem),R
  - { name: AND,   op: 0x2c8, ctl: { alu: AND,  cx:    , srca: rmem, ld: md,  setw: ,  wr: 1, swp_opnd:  , swp_ral:  ,cc: "${AND_CC}", ral:    }, mask: 0x3f8 } # R,(mem) / (mem),R
  - { name: ANDCF, op: 0x128, ctl: { alu: BAND, cx: cin, srca: acc,  ld:   ,  setw: ,  wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # A,r
  - { name: ANDCF, op: 0x120, ctl: { alu: BAND, cx: cin, srca: n41pp,ld:   ,  setw: ,  wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # #4,r
  - { name: ANDCF, op: 0x328, ctl: { alu: BAND, cx: cin, srca: acc,  ld:   ,  setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # A,(mem) 1'm11'mmmm
  - { name: ANDCF, op: 0x380, ctl: { alu: BAND, cx: cin, srca: n31p, ld:   ,  setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }, mask: 0x3f8 } # #3,(mem)
  - { name: BIT,   op: 0x133, ctl: { alu: BXOR, cx: hi,  srca: n41pp,ld:   ,  setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: "${BIT_CC}", ral:    }} # #4,r
  - { name: BIT,   op: 0x3c8, ctl: { alu: BXOR, cx: hi,  srca: n31p, ld:   ,  setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: "${BIT_CC}", ral:    }, mask: 0x3f8 } # #3,(mem)
  - { name: CCF,   op: 0x012, ctl: { alu:     , cx: com, srca: imm1, ld:   ,  setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: n0c        , ral:    }}
  - { name: CHG,   op: 0x132, ctl: { alu: BXOR, cx: hi,  srca: n41pp,ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # #4,r
  - { name: CHG,   op: 0x3c0, ctl: { alu: BXOR, cx: hi,  srca: n31p, ld: md,  setw: b, wr: 1, swp_opnd:  , swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 } # #3,(mem)
  - { name: CP,    op: 0x1cf, ctl: { alu: SUB,  cx:   ,  srca: imm1, ld:    , setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }} # r,#
  - { name: CP,    op: 0x1d8, ctl: { alu: SUB,  cx:   ,  srca: n31p, ld:    , setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }, mask: 0x3f8 } # r,#
  - { name: CP,    op: 0x1f0, ctl: { alu: SUB,  cx:   ,  srca: reg,  ld:    , setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }, mask: 0x3f8 }            # R,r
  - { name: CP,    op: 0x23f, ctl: { alu: SUB,  cx:   ,  srca: imm0, ld:  md, setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }} # <W> (mem),#
  - { name: CP,    op: 0x2f0, ctl: { alu: SUB,  cx:   ,  srca: rmem, ld:    , setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }, mask: 0x3f8 } # R,(mem) / (mem),R
  - { name: CP,    op: 0x2f8, ctl: { alu: SUB,  cx:   ,  srca: rmem, ld:    , setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }, mask: 0x3f8 } # R,(mem) / (mem),R
  - { name: CPL,   op: 0x106, ctl: { alu: CPL,  cx:   ,  srca: zero, ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: h1n1       , ral:    }} # only byte/word
  - { name: DAA,   op: 0x110, ctl: { alu: ADD,  cx:   ,  srca: daa,  ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: szhvcr     , ral:    }}
  - { name: DEC,   op: 0x168, ctl: { alu: SUB,  cx:   ,  srca: n31p, ld: dst, setw:  , wr: 0, swp_opnd:  , swp_ral:  ,cc: "${DEC_CC}", ral:    }, mask: 0x3f8 } # DEC #3,r
  - { name: DEC,   op: 0x268, ctl: { alu: SUB,  cx:   ,  srca: n31p, ld:  md, setw:  , wr: 1, swp_opnd: $, swp_ral:  ,cc: "${DEC_CC}", ral:    }, mask: 0x3f8 } # inc<w> #3,(mem)
  - { name: DECF,  op: 0x00d, ctl: { alu: SUB,  cx: hi,  srca: rfp,  ld: rfp, setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }}
  - { name: EI,    op: 0x006, ctl: { alu:    ,  cx:   ,  srca: n30pp,ld: iff, setw: b, wr:  , swp_opnd: $, swp_ral:  ,cc:            , ral:    }} # also serves as DI when operand is 7
  - { name: INC,   op: 0x160, ctl: { alu: ADD,  cx:   ,  srca: n31p, ld: dst, setw:  , wr: 0, swp_opnd:  , swp_ral:  ,cc: "${INC_CC}", ral:    }, mask: 0x3f8 } # INC #3,r
  - { name: INC,   op: 0x260, ctl: { alu: ADD,  cx:   ,  srca: n31p, ld:  md, setw:  , wr: 1, swp_opnd:  , swp_ral:  ,cc: "${INC_CC}", ral:    }, mask: 0x3f8 } # inc<w> #3,(mem)
  - { name: INCF,  op: 0x00c, ctl: { alu: ADD,  cx: hi,  srca: rfp,  ld: rfp, setw: b, wr: ,  swp_opnd:  , swp_ral:  ,cc:            , ral:    }}
  - { name: LD,    op: 0x200, ctl: { alu:    ,  cx:   ,  srca: imm0, ld:  md, setw: b, wr: 1, swp_opnd: $, swp_ral:  ,cc:            , ral: dst}} # LD<B> (mem),#
  - { name: LD,    op: 0x202, ctl: { alu:    ,  cx:   ,  srca: imm0, ld:  md, setw: b, wr: 1, swp_opnd: $, swp_ral:  ,cc:            , ral: dst}} # LD<W> (mem),#
  - { name: LD,    op: 0x020, ctl: { alu:    ,  cx:   ,  srca: imm0, ld: dst, setw: b, wr: ,  swp_opnd:  , swp_ral:  ,cc:            , ral: dst}, mask: 0x3f8 } # LD R,# zzz encoding
  - { name: LD,    op: 0x030, ctl: { alu:    ,  cx:   ,  srca: imm0, ld: dst, setw: w, wr: ,  swp_opnd:  , swp_ral:  ,cc:            , ral: dst}, mask: 0x3f8 } # LD R,# zzz encoding
  - { name: LD,    op: 0x040, ctl: { alu:    ,  cx:   ,  srca: imm0, ld: dst, setw: q, wr: ,  swp_opnd:  , swp_ral:  ,cc:            , ral: dst}, mask: 0x3f8 } # LD R,# zzz encoding
  - { name: LD,    op: 0x103, ctl: { alu:    ,  cx:   ,  srca: imm0, ld: dst, setw:  , wr: ,  swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # LD r,# # r,#
  - { name: LD,    op: 0x188, ctl: { alu:    ,  cx:   ,  srca: reg,  ld: dst, setw:  , wr: ,  swp_opnd: $, swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 } # LD R,r
  - { name: LD,    op: 0x198, ctl: { alu:    ,  cx:   ,  srca: reg,  ld: dst, setw:  , wr: ,  swp_opnd:  , swp_ral: $,cc:            , ral:    }, mask: 0x3f8 } # LD r,R
  - { name: LD,    op: 0x1a8, ctl: { alu:    ,  cx:   ,  srca: n31p, ld: dst, setw:  , wr: ,  swp_opnd: $, swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 } # LD r,#3 #
  - { name: LD,    op: 0x220, ctl: { alu:    ,  cx:   ,  srca: rmem, ld: dst, setw:  , wr: ,  swp_opnd: $, swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 } # LD R,(mem)
  - { name: LD,    op: 0x300, ctl: { alu:    ,  cx:   ,  srca: imm0, ld: md,  setw: b, wr: 1, swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # LD<W> (mem),#
  - { name: LD,    op: 0x302, ctl: { alu:    ,  cx:   ,  srca: imm0, ld: md,  setw: w, wr: 1, swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # LD<W> (mem),#
  - { name: LD,    op: 0x314, ctl: { alu:    ,  cx:   ,  srca: dir16,ld:   ,  setw: b, wr: 1, swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # LD<B> (mem),(#16)
  - { name: LD,    op: 0x316, ctl: { alu:    ,  cx:   ,  srca: dir16,ld:   ,  setw: w, wr: 1, swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # LD<W> (mem),(#16)
  - { name: LD,    op: 0x340, ctl: { alu:    ,  cx:   ,  srca: reg,  ld: md,  setw: b, wr: 1, swp_opnd: $, swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 } # LD (mem),R
  - { name: LD,    op: 0x350, ctl: { alu:    ,  cx:   ,  srca: reg,  ld: md,  setw: w, wr: 1, swp_opnd: $, swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 } # LD (mem),R
  - { name: LD,    op: 0x360, ctl: { alu:    ,  cx:   ,  srca: reg,  ld: md,  setw: q, wr: 1, swp_opnd: $, swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 } # LD (mem),R
  - { name: LDA,   op: 0x320, ctl: { alu:    ,  cx:   ,  srca: ea0,  ld: dst, setw: w, wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 }
  - { name: LDA,   op: 0x330, ctl: { alu:    ,  cx:   ,  srca: ea0,  ld: dst, setw: q, wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 }
  - { name: LDC,   op: 0x12e, ctl: { alu:    ,  cx:   ,  srca: cr1,  ld: cr , setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # LDC cr,r
  - { name: LDC,   op: 0x12f, ctl: { alu:    ,  cx:   ,  srca: cr0,  ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # LDC r,cr
  - { name: LDCF,  op: 0x12b, ctl: { alu: BOR,  cx:   ,  srca: acc,  ld:    , setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # A,r
  - { name: LDCF,  op: 0x123, ctl: { alu: BOR,  cx:   ,  srca: n41pp,ld:    , setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # #4,r
  - { name: LDCF,  op: 0x32b, ctl: { alu: BOR,  cx:   ,  srca: acc,  ld:    , setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # A,(mem) 1'm11'mmmm
  - { name: LDCF,  op: 0x398, ctl: { alu: BOR,  cx:   ,  srca: n31p, ld:    , setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }, mask: 0x3f8 } # #3,(mem)
  - { name: LDF,   op: 0x017, ctl: { alu: ,     cx:   ,  srca: n30pp,ld: rfp, setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }}
  - { name: MIRR,  op: 0x116, ctl: { alu: MIRR, cx:   ,  srca: zero, ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # only byte
  - { name: NEG,   op: 0x107, ctl: { alu: SUB,  cx:   ,  srca: zero, ld: dst, setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }} # only byte/word
  - { name: NOP,   op: 0x000, ctl: { alu: ,     cx:   ,  srca: zero, ld:    , setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }}
  - { name: OR,    op: 0x1ce, ctl: { alu: OR,   cx:   ,  srca: imm1, ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: "${OR_CC}" , ral:    }} # r,#
  - { name: OR,    op: 0x1e0, ctl: { alu: OR,   cx:   ,  srca: reg,  ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral: $,cc: "${OR_CC}" , ral:    }, mask: 0x3f8 }            # R,r
  - { name: OR,    op: 0x23e, ctl: { alu: OR,   cx:   ,  srca: imm0, ld: md,  setw:  , wr: 1, swp_opnd:  , swp_ral:  ,cc: "${OR_CC}" , ral:    }} # <W> (mem),#
  - { name: OR,    op: 0x2e0, ctl: { alu: OR,   cx:   ,  srca: rmem, ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: "${OR_CC}" , ral:    }, mask: 0x3f8 } # R,(mem) / (mem),R
  - { name: OR,    op: 0x2e8, ctl: { alu: OR,   cx:   ,  srca: rmem, ld: md,  setw:  , wr: 1, swp_opnd:  , swp_ral:  ,cc: "${OR_CC}" , ral:    }, mask: 0x3f8 } # R,(mem) / (mem),R
  - { name: ORCF,  op: 0x129, ctl: { alu: BOR,  cx: cin, srca: acc,  ld:   ,  setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # A,r
  - { name: ORCF,  op: 0x121, ctl: { alu: BOR,  cx: cin, srca: n41pp,ld:   ,  setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # #4,r
  - { name: ORCF,  op: 0x329, ctl: { alu: BOR,  cx: cin, srca: acc,  ld:   ,  setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # A,(mem) 1'm11'mmmm
  - { name: ORCF,  op: 0x388, ctl: { alu: BOR,  cx: cin, srca: n31p, ld:   ,  setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }, mask: 0x3f8 } # #3,(mem)
  - { name: PAA,   op: 0x114, ctl: { alu: ADD,  cx:  b0, srca: zero, ld: dst, setw:  , wr: 0, swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # PAA r
  - { name: RCF,   op: 0x010, ctl: { alu: BAND, cx:    , srca: imm1, ld:    , setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: h0n0c      , ral:    }}
  - { name: RES,   op: 0x130, ctl: { alu: BSET, cx:    , srca: n41pp,ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # #4,r
  - { name: RES,   op: 0x3b0, ctl: { alu: BAND, cx:    , srca: n31p, ld: md,  setw: b, wr: 1, swp_opnd:  , swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 } # #3,(mem)
  - { name: SBC,   op: 0x1b0, ctl: { alu: SUB,  cx: cin, srca: reg,  ld: dst, setw:  , wr:  , swp_opnd: $, swp_ral: $,cc: "${SUB_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,r
  - { name: SBC,   op: 0x1cb, ctl: { alu: SUB,  cx: cin, srca: imm1, ld: dst, setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }} # r,#
  - { name: SBC,   op: 0x23b, ctl: { alu: SUB,  cx: cin, srca: imm0, ld: md,  setw:  , wr: 1, swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }} # <W> (mem),#
  - { name: SBC,   op: 0x2b0, ctl: { alu: SUB,  cx: cin, srca: rmem, ld: dst, setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,(mem) / (mem),R
  - { name: SBC,   op: 0x2b8, ctl: { alu: SUB,  cx: cin, srca: rmem, ld: md,  setw:  , wr: 1, swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,(mem) / (mem),R
  - { name: SCC,   op: 0x170, ctl: { alu:     , cx:    , srca: cc0,  ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral: , cc:            , ral:    }, mask: 0x3f0 } # SCC cc,r cc = #4
  - { name: SCF,   op: 0x011, ctl: { alu:     , cx:  hi, srca: imm1, ld:   ,  setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: h0n0c      , ral:    }}
  - { name: SET,   op: 0x131, ctl: { alu: BSET, cx:  hi, srca: n41pp,ld: dst, setw: ,  wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # #4,r
  - { name: SET,   op: 0x3b8, ctl: { alu: BOR,  cx:  hi, srca: n31p, ld: md,  setw: b, wr: 1, swp_opnd:  , swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 } # #3,(mem)
  - { name: STCF,  op: 0x124, ctl: { alu: BSET, cx: cin, srca: n41pp,ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # #4,r
  - { name: STCF,  op: 0x32c, ctl: { alu: BSET, cx: cin, srca: acc,  ld: md,  setw: b, wr: 1, swp_opnd:  , swp_ral:  ,cc:            , ral:    }} # A,(mem) 1'm11'mmmm
  - { name: STCF,  op: 0x3a0, ctl: { alu: BSET, cx: cin, srca: n31p, ld: md,  setw: b, wr: 1, swp_opnd:  , swp_ral:  ,cc:            , ral:    }, mask: 0x3f8 } # #3,(mem)
  - { name: SUB,   op: 0x1a0, ctl: { alu: SUB,  cx:    , srca: reg,  ld: dst, setw:  , wr:  , swp_opnd: $, swp_ral: $,cc: "${SUB_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,r
  - { name: SUB,   op: 0x1ca, ctl: { alu: SUB,  cx:    , srca: imm1, ld: dst, setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }} # r,#
  - { name: SUB,   op: 0x23a, ctl: { alu: SUB,  cx:    , srca: imm0, ld: md,  setw:  , wr: 1, swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }} # <W> (mem),#
  - { name: SUB,   op: 0x2a0, ctl: { alu: SUB,  cx:    , srca: rmem, ld: dst, setw:  , wr:  , swp_opnd: $, swp_ral:  ,cc: "${SUB_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,(mem) / (mem),R
  - { name: SUB,   op: 0x2a8, ctl: { alu: SUB,  cx:    , srca: rmem, ld: dst, setw:  , wr: 1, swp_opnd: $, swp_ral: $,cc: "${SUB_CC}", ral:    }, mask: 0x3f8, cycles: 1 } # R,(mem) / (mem),R
  - { name: TSET,  op: 0x134, ctl: { alu: BSET, cx:  hi, srca: n41pp,ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: "${BIT_CC}", ral:    }} # #4,r
  - { name: TSET,  op: 0x3a8, ctl: { alu: BSET, cx:  hi, srca: n31p, ld: md,  setw: b, wr: 1, swp_opnd:  , swp_ral:  ,cc: "${BIT_CC}", ral:    },  mask: 0x3f8 } # #3,(mem)
  - { name: XOR,   op: 0x1cd, ctl: { alu: XOR,  cx:    , srca: imm1, ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: "${OR_CC}" , ral:    }} # r,#
  - { name: XOR,   op: 0x1d0, ctl: { alu: XOR,  cx:    , srca: reg,  ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: "${OR_CC}" , ral:    }, mask: 0x3f8, cycles: 1 } # R,r
  - { name: XOR,   op: 0x23d, ctl: { alu: XOR,  cx:    , srca: imm0, ld: md,  setw:  , wr: 1, swp_opnd:  , swp_ral:  ,cc: "${OR_CC}" , ral:    }} # <W> (mem),#
  - { name: XOR,   op: 0x2d0, ctl: { alu: XOR,  cx:    , srca: rmem, ld: dst, setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: "${OR_CC}" , ral:    }, mask: 0x3f8, cycles: 1 } # R,(mem) / (mem),R
  - { name: XOR,   op: 0x2d8, ctl: { alu: XOR,  cx:    , srca: rmem, ld: dst, setw:  , wr: 1, swp_opnd:  , swp_ral:  ,cc: "${OR_CC}" , ral:    }, mask: 0x3f8, cycles: 1 } # R,(mem) / (mem),R
  - { name: XORCF, op: 0x12A, ctl: { alu: BXOR, cx: cin, srca: acc,  ld:    , setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # A,r
  - { name: XORCF, op: 0x122, ctl: { alu: BXOR, cx: cin, srca: n41pp,ld:    , setw:  , wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # #4,r
  - { name: XORCF, op: 0x32a, ctl: { alu: BXOR, cx: cin, srca: acc,  ld:    , setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }} # A,(mem) 1'm11'mmmm
  - { name: XORCF, op: 0x390, ctl: { alu: BXOR, cx: cin, srca: n31p, ld:    , setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: c          , ral:    }, mask: 0x3f8 } # #3,(mem)
  - { name: ZCF,   op: 0x013, ctl: { alu:     , cx:  zf, srca: imm1, ld:    , setw: b, wr:  , swp_opnd:  , swp_ral:  ,cc: n0c        , ral:    }}

  - { name: DIV,   op: 0x150, ctl: { alu: DIV,  ex: zex, src: dst, swp: 1, cc: v },                                          mask: 0x3f8 } # only byte/word
  - { name: DIV,   op: 0x250, ctl: { alu: DIV,  ex: zex, src: md,  swp:  , cc: v }, mask: 0x3f8 } # DIV  RR,(mem)
  - { name: DIVS,  op: 0x158, ctl: { alu: DIVS, ex: sex, src: dst, swp: 1, cc: v },                                          mask: 0x3f8 } # only byte/word
  - { name: DIVS,  op: 0x258, ctl: { alu: DIVS, ex: sex, src: md,  swp:  , cc: v }, mask: 0x3f8 } # DIVS RR,(mem)
  - { name: MUL,   op: 0x140, ctl: { alu: MUL,  ex: zex, src: dst, swp: 1 },                                     mask: 0x3f8 } # only byte/word
  - { name: MUL,   op: 0x240, ctl: { alu: MUL,  ex: zex, src: md,  swp:   }, mask: 0x3f8 } # MUL  RR,(mem)
  - { name: MULS,  op: 0x148, ctl: { alu: MULS, ex: sex, src: dst, swp: 1 },                                     mask: 0x3f8 } # only byte/word
  - { name: MULS,  op: 0x248, ctl: { alu: MULS, ex: sex, src: md,  swp:   }, mask: 0x3f8 } # MULS RR,(mem)
  - { name: DIVI,  op: 0x10a, ctl: { alu: DIV,  ex: zex, cc: v }} # r,#
  - { name: DIVSI, op: 0x10b, ctl: { alu: DIVS, ex: sex, cc: v }} # r,#
  - { name: MULI,  op: 0x108, ctl: { alu: MUL,  ex: zex        }} # r,#
  - { name: MULSI, op: 0x109, ctl: { alu: MULS, ex: sex        }} # r,#

  - { name: MULA,  op: 0x119, ctl: { cc: szv }}
  # group 1 - r
  - { name: BS1B,   op: 0x10f, ctl: { alu:      , cc: z2v }}
  - { name: BS1F,   op: 0x10e, ctl: { alu: MIRR , cc: z2v }}
  - { name: DJNZ,   op: 0x11c }
  - { name: EXTS,   op: 0x113, ctl: { ext: sex }}
  - { name: EXTZ,   op: 0x112, ctl: { ext: zex }}
  - { name: POP,    op: 0x105, ctl: { dst: dst, setw: , wr: }} # POP r
  - { name: PUSHR2, op: 0x104 } # PUSH r
  # group 1 but limited valid addressing
  - { name: LINK,  op: 0x10c                } # only long word
  - { name: MDEC1, op: 0x13c, ctl: { setw: b, alu: sub }} # only word
  - { name: MDEC2, op: 0x13d, ctl: { setw: w, alu: sub }} # only word
  - { name: MDEC4, op: 0x13e, ctl: { setw: q, alu: sub }} # only word
  - { name: MINC1, op: 0x138, ctl: { setw: b, alu: add }} # only word
  - { name: MINC2, op: 0x139, ctl: { setw: w, alu: add }} # only word
  - { name: MINC4, op: 0x13a, ctl: { setw: q, alu: add }} # only word
  - { name: RLA,   op: 0x1fa, ctl: { alu: SHL, srca: acc, cx: cin,cc: "${SH_CC}" }} # register A always used RL  A,r
  - { name: RRA,   op: 0x1fb, ctl: { alu: SHR, srca: acc, cx: cin,cc: "${SH_CC}" }} # register A always used RR  A,r
  - { name: RLCA,  op: 0x1f8, ctl: { alu: SHL, srca: acc, cx: sa, cc: "${SH_CC}" }} # register A always used RLC A,r
  - { name: RRCA,  op: 0x1f9, ctl: { alu: SHR, srca: acc, cx: sh, cc: "${SH_CC}" }} # register A always used RRC A,r
  - { name: SLAA,  op: 0x1fc, ctl: { alu: SHL, srca: acc, cx:   , cc: "${SH_CC}"  }, opmask: 0x3fd } # register A always used SLL A,r SLA=SLL
  - { name: SRAA,  op: 0x1fd, ctl: { alu: SHR, srca: acc, cx: sa, cc: "${SH_CC}"  }} # register A always used SRA A,r
  - { name: SRLA,  op: 0x1ff, ctl: { alu: SHR, srca: acc, cx:   , cc: "${SH_CC}"  }} # register A always used SRL A,r
  - { name: UNLK,  op: 0x10d                } # first byte always 0xe8 & 0xf8
  # #4,r
  - { name: RL,    op: 0x1ea, ctl: { alu: SHL,  srca: n41pp, cc: "${SH_CC}", cx: cin }}
  - { name: RLC,   op: 0x1e8, ctl: { alu: SHL,  srca: n41pp, cc: "${SH_CC}", cx: sa  }}
  - { name: RR,    op: 0x1eb, ctl: { alu: SHR,  srca: n41pp, cc: "${SH_CC}", cx: cin }}
  - { name: RRC,   op: 0x1e9, ctl: { alu: SHR,  srca: n41pp, cc: "${SH_CC}", cx: sh  }}
  - { name: SLA,   op: 0x1ec, ctl: { alu: SHL,  srca: n41pp, cc: "${SH_CC}", cx:     }, opmask: 0x3fd } # SLA=SLL
  - { name: SRA,   op: 0x1ed, ctl: { alu: SHR,  srca: n41pp, cc: "${SH_CC}", cx: sa  }}
  - { name: SRL,   op: 0x1ef, ctl: { alu: SHR,  srca: n41pp, cc: "${SH_CC}", cx:     }}

  - { name: EX,    op: 0x1b8, ctl: { srca: reg,  ld: dst, wr:   }, mask: 0x3f8 } # EX R,r
  - { name: EX,    op: 0x230, ctl: { srca: rmem, ld: md,  wr: 1 }, mask: 0x3f8 } # EX (mem),r

  # group 2 - R,(mem) - (mem),R
  - { name: PUSHM, op: 0x204 } # PUSH<W> (mem)
  - { name: RLCM,  op: 0x278, ctl: { alu: SHL, cc: "${SH_CC}", cx: sa  }}
  - { name: RRCM,  op: 0x279, ctl: { alu: SHR, cc: "${SH_CC}", cx: sh  }}
  - { name: RLM,   op: 0x27a, ctl: { alu: SHL, cc: "${SH_CC}", cx: cin }}
  - { name: RRM,   op: 0x27b, ctl: { alu: SHR, cc: "${SH_CC}", cx: cin }}
  - { name: SLAM,  op: 0x27c, ctl: { alu: SHL, cc: "${SH_CC}", cx:     }, opmask: 0x3fd } # SLA=SLM
  - { name: SRAM,  op: 0x27d, ctl: { alu: SHR, cc: "${SH_CC}", cx: sa  }}
  - { name: SRLM,  op: 0x27f, ctl: { alu: SHR, cc: "${SH_CC}", cx:     }}
  # Group 2 - string instructions
  - { name: CPD,   op: 0x216, ctl: { step: SUB, cc: "${DEC_CC}", loop: 0 }}
  - { name: CPDR,  op: 0x217, ctl: { step: SUB, cc: "${DEC_CC}", loop: 1 }}
  - { name: CPI,   op: 0x214, ctl: { step: ADD, cc: "${DEC_CC}", loop: 0 }}
  - { name: CPIR,  op: 0x215, ctl: { step: ADD, cc: "${DEC_CC}", loop: 1 }}
  - { name: LDD,   op: 0x212, ctl: { step: SUB, cc: "${LD_CC}" , loop: 0 }} # XDE,XHL or XIX,XIY is based on the first byte. v becomes ~z_out
  - { name: LDDR,  op: 0x213, ctl: { step: SUB, cc: "${LD_CC}" , loop: 1 }} # v3, becomes v0 at the end of the instruction
  - { name: LDI,   op: 0x210, ctl: { step: ADD, cc: "${LD_CC}" , loop: 0 }} # XDE,XHL or XIX,XIY is based on the first byte
  - { name: LDIR,  op: 0x211, ctl: { step: ADD, cc: "${LD_CC}" , loop: 1 }} # v3, becomes v0 at the end of the instruction
  # group 2 1m00'mmmm limited byte size
  - { name: RLD,   op: 0x206, ctl: { alu: RLD, cc: szh0vn0 }} # RLD [A,](mem)
  - { name: RRD,   op: 0x207, ctl: { alu: RRD, cc: szh0vn0 }} # RRD [A,](mem)
  - { name: LDM2DA,op: 0x219 }              # LD<W> (#16),(mem)

  # group 3 1m11'mmmm
  - { name: RETcc, op: 0x3f0, ctl: { retd: 0, ncc: ncc }, mask: 0x3f0 } # Decoded in control unit directly as a 12-bit OP
  - { name: LDAR,  op: 0x313 }
  - { name: JPM,   op: 0x3d0, mask: 0x3f0 } # JP [cc,]mem
  # group 3 1m11'mmmm #3,(mem)
  - { name: CALLcc,op: 0x3e0,                                                    mask: 0x3f0 }
  - { name: POPM,  op: 0x304, ctl: { dst: md, wr: 1, setw: b }}
  - { name: POPM,  op: 0x306, ctl: { dst: md, wr: 1, setw: w }}

ucode:
  - name: intexec
    seq:
      - # let the memory unit grab the address
      - waitmem, q_fetch
      - ni
  - mnemo: [ mem_reg ] # (XWA), (XSP)... no indexing and
    seq:               # (XWA+d8), 8-bit indexing
      - inc_pc, q_setw, s8_fetch
      - dst_ral
      - dst_rmux, ld0_opnd, b_setw
      - ?${d8}=1, sex, ld1_opnd, q_setw
      - ?${d8}=1, add_alu, da_ld, ld0_opnd, ${setw}_setw
      - ?${d8}=0,          da_ld, ld0_opnd, ${setw}_setw
      - ?${rd}=1, da2ea2md_jsr
      - ?${rd}=0, da2ea, g3_nxgr,ni # EA has the address, MD keeps the OP
  - mnemo: [ mem_da ]
    seq:
      - inc_pc, b_setw, s8_fetch    # #8 by default
      - ?${off16}, inc_pc, w_setw   # #16 if off16 is set
      - zex, ld0_opnd, q_setw
      - da_ld, ${setw}_setw, ld0_opnd
      - ?${rd}=1, da2ea2md_jsr
      - ?${rd}=0, da2ea, g3_nxgr,ni # EA has the address, MD keeps the OP
  - mnemo: [ mem_da24 ]
    seq:
      - inc_pc, q_setw, s8_fetch
      - inc_pc, ld0_opnd
      - inc_pc, da_ld
      - inc_pc
      - waitmem, q_fetch # need to fetch new data
      - ${setw}_setw, ld0_opnd
      - ?${rd}=1, da2ea2md_jsr
      - ?${rd}=0, da2ea, g3_nxgr,ni # EA has the address, MD keeps the OP
  - mnemo: [ mem_r32 ]
    seq: # covers r32', r32'+d16, r32+r8, r32+r16
      - ${setw}_setw, inc_pc, s8_fetch
      - ?${rd}=0, r32jmp, alt
      - ?${rd}=1, r32jmp,       # r32 jump is based on lower bits
  - mnemo: [ mem_iter ]
    seq: # pre-decrement / post-increment
      - inc_pc, q_setw, s8_fetch
      - dst_ral
      - dst_rmux, ld0_opnd, ${setw}_setw
      - spd_rmux, ld1_opnd, q_setw
      - ${alu}_alu, dst_ld
      - ${adr}_alu, da_ld
      - ${setw}_setw
      - da2ea
      - ?${rd}=1, m_ea, waitmem, vs_fetch
      - ?${rd}=1, g2_nxgr, ni
      - ?${rd}=0, g3_nxgr, ni # EA has the address, MD keeps the OP
  - name: da2ea2md
    seq: # loads operand data in op0, sets ea, and md contains the next op
      - da2ea # op-code data is held in op0
      - m_ea, q_fetch, waitmem # loads data in md
      - ld1_opnd # operand data in md
      - md_ld, swp_opnd # restores md to have op code, operand data in op0
      - g2_nxgr, ni
  - name: r32_00
    seq:
      - swp_setw
      - inc_pc, alt, dst_ral, q_setw
      - dst_rmux, ld0_opnd
      - da_ld
      - r32com_jsr
  - name: r32_00_nord
    seq:
      - inc_pc, alt, dst_ral, q_setw
      - dst_rmux, ld0_opnd
      - da_ld, waitmem, q_fetch
      - g3_nxgr, ni
  - name: r32_01
    seq:
      - swp_setw
      - inc_pc, alt, dst_ral, q_setw, s8_fetch
      - inc_pc, dst_rmux, ld0_opnd, w_setw
      - inc_pc, sex, md_rmux, ld1_opnd, q_setw
      - add_alu, da_ld
      - r32com_jsr
  - name: r32_01_nord
    seq:
      - inc_pc, alt, dst_ral, q_setw, s8_fetch
      - inc_pc, dst_rmux, ld0_opnd, w_setw
      - inc_pc, sex, md_rmux, ld1_opnd, q_setw
      - add_alu, da_ld, waitmem, q_fetch
      - g3_nxgr, ni
  - name: r32_8 # 2nd memory addressing byte code: 0000'0011
    seq:
      - swp_setw
      - inc_pc, s8_fetch, q_setw
      - inc_pc, s8_fetch, alt, dst_ral
      - dst_rmux, ld0_opnd, b_setw
      - alt, dst_ral
      - dst_rmux, ld1_opnd
      - add_alu, da_ld
      - r32com_jsr
  - name: r32_16 # 2nd memory addressing byte code: 0000'0111
    seq:
      - swp_setw
      - inc_pc, s8_fetch, q_setw
      - inc_pc, s8_fetch, alt, dst_ral
      - dst_rmux, ld0_opnd, w_setw
      - alt, dst_ral
      - dst_rmux, ld1_opnd
      - add_alu, da_ld
      - r32com_jsr
  - name: r32_8_nord # 2nd memory addressing byte code: 0000'0011
    seq:
      - swp_setw
      - inc_pc, s8_fetch, q_setw
      - inc_pc, s8_fetch, alt, dst_ral
      - dst_rmux, ld0_opnd, b_setw
      - alt, dst_ral
      - dst_rmux, ld1_opnd
      - add_alu, da_ld, waitmem, q_fetch
      - g3_nxgr, ni
  - name: r32_16_nord # 2nd memory addressing byte code: 0000'0111
    seq:
      - swp_setw
      - inc_pc, s8_fetch, q_setw
      - inc_pc, s8_fetch, alt, dst_ral
      - dst_rmux, ld0_opnd, w_setw
      - alt, dst_ral
      - dst_rmux, ld1_opnd
      - add_alu, da_ld, waitmem, q_fetch
      - g3_nxgr, ni
  - name: r32_ldar  # 2nd byte: 0001'0011, don't increment PC and jump to LDAR
    seq:
      - g3_nxgr, ni
  - name: r32com
    seq:
      - da2ea, swp_setw
      - m_ea, q_fetch, waitmem
      - ld0_opnd
      - waitmem, q_fetch
      - g2_nxgr, ni
  - name: reg
    seq: # Load op1 operand (source)
      - inc_pc
      - src_ral, s8_fetch
      - src_rmux, ld1_opnd, ret_jsr
  - name: rmem
    seq: # Load op0 operand (destination)
      - inc_pc,   dst_ral
      - dst_rmux, ld0_opnd
      - swp_opnd, ret_jsr
  - name: cr0
    seq:
      - inc_pc, s8_fetch
      - inc_pc, cr_rd
      - cr_rmux, ld0_opnd, ret_jsr  # loaded into op0 because it is used for a transfer only
  - name: cr1
    seq:
      - inc_pc, s8_fetch
      - inc_pc, ret_jsr  # loaded into md
  - name: imm0
    seq:
      - inc_pc
      - waitmem, q_fetch               # guarantees that the data will be valid in all cases
      - inc_pc, retb, zex, ld0_opnd    # conditional return on byte size
      - inc_pc, retw                   # conditional return on word size
      - inc_pc
      - inc_pc, ret_jsr
  - name: imm1
    seq:
      - inc_pc
      - waitmem, q_fetch               # guarantees that the data will be valid in all cases
      - inc_pc, retb, zex, ld1_opnd    # conditional return on byte size
      - inc_pc, retw                   # conditional return on word size
      - inc_pc
      - inc_pc, ret_jsr
  - name: zero
    seq: # increments PC despite not reading data, so it can be used in the general OP template
      - inc_pc, s8_fetch, zero_rmux, ld1_opnd, ret_jsr
  - name: rfp
    seq: # loads rfp to op0 and zero to op1
      - inc_pc, rfp_rmux, ld0_opnd
      - zero_rmux, ld1_opnd, ret_jsr
  - name: daa
    seq:
      - inc_pc, daa_alu, md_ld
      - ld1_opnd, ret_jsr
  - name: cc0
    seq:
      - inc_pc, cc_rmux, ld0_opnd, ret_jsr
  - name: imm24
    seq:
      - inc_pc
      - inc_pc, s8_fetch
      - inc_pc
      - inc_pc, ret_jsr
  - name: acc
    seq:
      - inc_pc, a_ral
      - src_rmux, ld1_opnd, ret_jsr
  - name: n41pp # #4 -> op1, pc+=2
    seq: # note that it consumes the first byte too, which contains the OP code
      - inc_pc, s8_fetch
      - inc_pc, n4_rmux, ld1_opnd, ret_jsr
  - name: n31p # #3 -> op1, pc+=1
    seq:
      - inc_pc, n3_rmux, ld1_opnd, s8_fetch, ret_jsr
  - name: n30pp # #3 -> op0, pc+=2
    seq:
      - inc_pc, s8_fetch
      - inc_pc, n3_rmux, ld0_opnd, ret_jsr
  - name: zni
    seq:
      - inc_pc
      - waitmem, q_fetch
      - ni
  - name: ncc     # used to finish an instruction if cc is not met
    seq:
      - inc_pc
      - waitmem, q_fetch
      - ni
  - name: psh
    seq: # pushes MD contents. b/w/qs must already be set
      - xsp_rmux, ld0_opnd
      - spd_rmux, ld1_opnd
      - sub_alu, xsp_ld
      - sp_ea, wr
      - waitmem, q_fetch
      - ni
  - name: dir16
    seq: # loads data from 16-bit address into MD. Does not set EA
      - s8_fetch, swp_setw      # load direct address from 16-bit immediate value
      - inc_pc, w_setw
      - inc_pc, zex, ld0_opnd
      - inc_pc, da_ld, swp_setw
      - da_ea, waitmem, vs_fetch
      - ret_jsr
  - name: ea0
    seq: # moves EA to op0 and increases PC
      - inc_pc, ea_rmux, ld0_opnd, ret_jsr
  ########################################################
  # Load op0 operand (destination)
  - mnemo: [ rzzB, rzzW, rzzQ ]
    seq:
      - inc_pc, ${setw}_setw, mulcheck
      - dst_ral
      - waitmem, q_fetch
      - g1_nxgr, ni, dst_rmux, ld0_opnd
  - mnemo: [ frzzB, frzzW, frzzQ ]
    seq:
      - inc_pc, ${setw}_setw, s8_fetch
      - inc_pc, alt, dst_ral, s8_fetch
      - waitmem, q_fetch
      - g1_nxgr, ni, dst_rmux, ld0_opnd
# instructions
  - mnemo: [  ADC, ADD, AND, ANDCF, BIT, CCF, CHG, CP, CPL,
              DAA, DEC, DECF, EI, INC, INCF, LD, LDA, LDC, LDCF, LDF,
              MIRR, NEG, NOP, OR, ORCF, PAA, RCF, RES,
              SBC, SCC, SCF, SET, STCF, SUB, TSET, XOR, XORCF, ZCF ]
    seq:
      - ${setw}_setw
      - ${ral}_ral, ${srca}_jsr
      - ${swp_opnd}, ${swp_ral}
      - ${alu}_alu, ${cx}_cx, ${ld}_ld, ${cc}_cc
      - ?${wr}, waitmem
      - ?${wr}, m_ea, wr
      - waitmem, q_fetch
      - ni
  # compare data and count up/down BC
  - mnemo: [ CPD, CPDR, CPI, CPIR ]
    seq:
      - set_loop, dst_rmux, ld0_opnd
      - da_ld, spd_rmux, ld1_opnd   # SRC pointer inc/dec in parallel
      - ${step}_alu, dst_ld, da_ea, vs_fetch  # variable-size fetch (byte or word)
      - a_ral
      - src_rmux, ld0_opnd
      - md_rmux,  ld1_opnd, waitmem
      - sub_alu, ${cc}_cc, bc_rmux, ld0_opnd # prepare for BC--
      - zero_rmux, ld1_opnd
      - sub_alu, hi_cx, bc_ld, z3v_cc # v = ~z
      - ?${loop}, nzv_loop  # loops while !z && v. This re-starts instruction execution. MD must not have changed!
      - inc_pc
      - waitmem, q_fetch
      - ni
  # copy data and count up/down BC
  - mnemo: [ LDD, LDDR, LDI, LDIR ]
    seq: # "src" used as destination and vice versa, because of how the instruction is encoded
      - dst_rmux, ld0_opnd, xsrc_ral
      - da_ld, spd_rmux, ld1_opnd   # SRC pointer inc/dec in parallel
      - ${step}_alu, dst_ld, da_ea  # variable-size fetch (byte or word)
      - waitmem, vs_fetch, src_rmux, ld0_opnd
      - da_ld, md_rmux,  ld0_opnd, swp_ral
      - da_ea, wr, ${step}_alu, dst_ld, swp_ral
      - zero_rmux, ld1_opnd
      - sub_alu, ${cc}_cc, bc_rmux, ld0_opnd # prepare for BC--
      - waitmem, sub_alu, hi_cx, bc_ld, z3v_cc # v = ~z
      - ?${loop}, nzv_loop  # loops while !z && v. This re-starts instruction execution. MD must not have changed!
      - inc_pc
      - waitmem, q_fetch
      - ni
  - mnemo: [ BS1F, BS1B ]
    seq:
      - ?${alu}, ${alu}_alu, md_ld  # for BS1F, this will mirror the operand
      - ?${alu}, ld0_opnd
      - inc_pc, bs1b_alu, a_ld, ${cc}_cc
      - waitmem, q_fetch
      - ni
  - mnemo: [ DJNZ ]
    seq:
      - inc_pc, s8_fetch                    # jump offset and PC adjustment
      - zero_rmux, ld1_opnd
      - sub_alu, hi_cx, dst_ld, b_setw, zni_jsr  # conditionally end if ALU's z output was set
      - inc_pc, sex, ld0_opnd, q_setw
      - pc_rmux, ld1_opnd
      - add_alu, pc_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ EX ]
    seq:
      - ${srca}_jsr
      - swp_ral
      - ${ld}_ld, swp_opnd, swp_ral
      - ?${wr}, m_ea, wr
      - dst_ld, waitmem, q_fetch
      - ni
  - mnemo: [ EXFF ]
    seq:
      - inc_pc, exff
      - waitmem, q_fetch
      - ni
  - mnemo: [ EXTS, EXTZ ]
    seq:
      - shrtn_setw
      - inc_pc, md_ld
      - ${ext}, ld0_opnd, widen_setw
      - dst_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ HALT ]
    seq:
      - inc_pc
      - halt
  - mnemo: [ JP ]
    seq:
      - ${setw}_setw, ${srca}_jsr
      - md_rmux, ld0_opnd
      - pc_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ JPM ]
    seq:
      - ncc_jsr             # finish if the cc condition is not met
      - ea_rmux, ld0_opnd   # no need for q_setw
      - pc_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ LD8 ]  # LD<W> (#8),#
    seq:
      - inc_pc, b_setw, s8_fetch      # load direct address from 8-bit immediate value
      - ld0_opnd
      - da_ld
      - ${setw}_setw, imm1_jsr
      - da_ea, wr
      - waitmem, q_fetch
      - ni
  - mnemo: [ LDM2DA ] # LD<W> (#16),(mem)
    seq:
      - inc_pc, swp_opnd              # moves (mem) from op0 to op1
      - inc_pc, s8_fetch, w_setw      # load direct address from 16-bit immediate value
      - inc_pc, zex, ld0_opnd
      - da_ld, swp_opnd               # restores (mem)
      - md_ld
      - da_ea, wr
      - waitmem, q_fetch
      - ni
  - mnemo: [ RET, RETcc, RETD ]
    seq:
      - inc_pc, s8_fetch, w_setw, ${ncc}_jsr      # sets ws for RETD
      - ?${retd}=1, inc_pc, zex, ld1_opnd, q_setw # imm at op1
      - ?${retd}=0, q_setw
      - sp_ea, waitmem, q_fetch
      - ld0_opnd
      - pc_ld, xsp_rmux, ld0_opnd
      - ?${retd}, inc_pc, add_alu, xsp_ld       # adds the deallocate portion
      - ?${retd}, xsp_rmux, ld0_opnd            # reloads XSP to add the rest
      - spd_rmux, ld1_opnd                      # regular +4
      - add_alu, xsp_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ CALR, CALL16, CALL24 ]
    seq:
      - inc_pc, s8_fetch
      - xsp_rmux, ld0_opnd, q_setw
      - spd_rmux, ld1_opnd
      - sub_alu, xsp_ld, ${setw}_setw       # XSP = XSP-4
      - inc_pc, ${ex}, ld0_opnd
      - ?${call24}, inc_pc
      - inc_pc, md_ld       # zex-applied MD
      - md_rmux, ld1_opnd   # store it in op1
      - pc_rmux, ld0_opnd, q_setw   # move PC to MD
      - md_ld, swp_opnd
      - sp_ea, wr           # push PC
      - ${alu}_alu, pc_ld               # PC gets the jump address
      - waitmem, q_fetch    # jump
      - ni
  - mnemo: [ CALLcc ]
    seq:
      - ncc_jsr
      - inc_pc, q_setw
      - xsp_rmux, ld0_opnd
      - spd_rmux, ld1_opnd
      - sub_alu, xsp_ld, q_setw # XSP = XSP-4
      - pc_rmux, ld0_opnd       # move PC to MD
      - md_ld, ea_rmux, ld0_opnd
      - pc_ld, sp_ea, wr               # push PC
      - waitmem, q_fetch
      - ni
  - mnemo: [ JR ]
    seq:
      - ?${jr16}, inc_pc
      - inc_pc, ncc_jsr
      - s8_fetch, ${setw}_setw
      - inc_pc, sex, ld0_opnd
      - pc_rmux, ld1_opnd
      - add_alu, pc_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ PUSHR, PUSHA, PUSHF, PUSHSR ]
    seq:
      - ?${pshr}=1, inc_pc, ${setw}_setw
      - ?${pshr}=1, dst_ral                       # dst_ral needed by PUSHR only
      - ?${pshr}=0, inc_pc, ${setw}_setw, a_ral   # a_ral needed by PUSHA only
      - ${rmux}_rmux, ld0_opnd
      - md_ld, psh_jsr
  - mnemo: [ PUSHR2 ]
    seq:
      - inc_pc, dst_rmux, ld0_opnd
      - md_ld, psh_jsr
  - mnemo: [ PUSHW ]
    seq:
      - inc_pc, ${setw}_setw, s8_fetch
      - ?${setw}=w, inc_pc
      - inc_pc, psh_jsr
  - mnemo: [ PUSHM ]
    seq:
      - inc_pc, md_ld
      - psh_jsr
  - mnemo: [ POP, POPM, POPF, POPA, POPSR ]
    seq:
      - inc_pc, ${setw}_setw
      - sp_ea, waitmem, vs_fetch, spd_rmux, ld1_opnd
      - ld0_opnd
      - ${dst}_ld, xsp_rmux, ld0_opnd
      - ?${wr}, m_ea, wr
      - add_alu, xsp_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ MINC1, MINC2, MINC4, MDEC1, MDEC2, MDEC4 ]
    seq:
      - ${setw}_setw
      - spd_rmux, ld1_opnd      # loads 1,2 or 4 to op1
      - w_setw, imm0_jsr        # op0 holds the register value
      - ${alu}_alu, op2_ld      # op2 holds the modified LSB
      - md_rmux, ld1_opnd       # op1 holds the mask
      - mod_alu, dst_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ SLA, SLAA, SRAA, SRLA, SRA, SRL, RLC, RRC, RL, RLA, RLCA, RR, RRA, RRCA ]
    seq:
      - op2_ld                  # what to shift in op2
      - ${srca}_jsr             # times to shift in op1
      - sh4_alu,  md_ld         # times to shift adjusted in MD
      - ld0_opnd,               # times to shift adjusted in op0
      - zero_rmux, ld1_opnd
      - ${alu}_alu,  ${cx}_cx, dst_ld, ${cc}_cc, set_loop
      - ${alu}_alu,  ${cx}_cx, op2_ld
      - sub_alu, hi_cx, md_ld
      - sub_alu, hi_cx, ld0_opnd, ni, nz_loop # if ALU's z is set returns, else loops around
  - mnemo: [  SLAM, SRAM, SRLM, RLCM, RRCM, RLM, RRM ]
    seq:
      - inc_pc, op2_ld
      - ${alu}_alu, ${cx}_cx, md_ld, ${cc}_cc
      - m_ea, wr
      - waitmem, q_fetch
      - ni
  - mnemo: [ RLD, RRD ]
    seq:
      - a_ral
      - src_rmux, ld1_opnd
      - ${alu}_alu, ${cc}_cc, a_ld
      - ${alu}_alu, md_ld
      - s8_fetch  # get the upper part of the ALU results
      - m_ea, wr
      - waitmem, q_fetch
      - ni
  - mnemo: [ MUL, MULS ]
    seq:
      - ?${swp}, swp_ral
      - inc_pc, mulsel, dst_ral
      - ${ex}, dst_rmux,    ld0_opnd
      - ${ex}, ${src}_rmux, ld1_opnd, widen_setw
      - ${alu}_alu, dst_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ MULI, MULSI ]
    seq:
      - inc_pc, s8_fetch
      - inc_pc, ${ex}, dst_rmux, ld0_opnd
      - inc_pc, ${ex}, md_rmux,  ld1_opnd, widen_setw
      - ${alu}_alu, dst_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ DIV, DIVS ]
    seq:
      - ?${swp}, swp_ral
      - inc_pc, mulsel, dst_ral
      - ${ex}, ${src}_rmux, ld1_opnd, widen_setw  # dst(q/w)÷src(w/b)
      - ${ex}, dst_rmux,    ld0_opnd
      - ${alu}_alu, div
      - ${alu}_alu, dst_ld, ${cc}_cc # ctrl logic will automatically wait for the ALU
      - waitmem, q_fetch
      - ni
  - mnemo: [ DIVI, DIVSI ]
    seq:
      - inc_pc, s8_fetch
      - inc_pc, ${ex}, md_rmux, ld1_opnd, widen_setw  # dst(q/w)÷src(w/b)
      - inc_pc, ${ex}, dst_rmux,    ld0_opnd
      - ${alu}_alu, div
      - ${alu}_alu, dst_ld, ${cc}_cc # ctrl logic will automatically wait for the ALU
      - waitmem, q_fetch
      - ni
  - mnemo: [ LDX ]
    seq:
      - inc_pc, s8_fetch
      - inc_pc, s8_fetch
      - inc_pc, ld0_opnd
      - inc_pc, da_ld, b_setw
      - waitmem, vs_fetch       # get only the next byte in (PC) for now
      - inc_pc, da_ea, wr
      - inc_pc
      - waitmem, q_fetch
      - ni
  - mnemo: [ LINK ]
    seq: # q_setw already set
      - inc_pc, xsp_rmux, ld0_opnd, s8_fetch
      - inc_pc, spd_rmux, ld1_opnd
      - inc_pc, sub_alu, xsp_ld
      - dst_rmux, ld0_opnd
      - md_rmux,  ld1_opnd, md_ld
      - sp_ea, wr
      - xsp_rmux, ld0_opnd
      - dst_ld
      - add_alu, xsp_ld
      - waitmem, q_fetch
      - ni
  - mnemo: [ UNLK ]
    seq: # q_setw already set
      - inc_pc, xsp_ld
      - sp_ea, q_fetch, waitmem
      - ld0_opnd, spd_rmux, ld1_opnd
      - dst_ld,   xsp_rmux, ld0_opnd
      - add_alu,  xsp_ld
      - waitmem,  q_fetch
      - ni
  - mnemo: [ LDAR ]
    seq: # loads EA to R register, comes here at 2nd byte
      - inc_pc, s8_fetch, w_setw
      - inc_pc, sex, ld0_opnd
      - inc_pc
      - inc_pc, pc_rmux, ld1_opnd, b_setw
      - waitmem, vs_fetch
      - dst_ral, s_setw             # decodes 001s'0RRR byte
      - inc_pc, add_alu, dst_ld
      - waitmem, vs_fetch
      - ni
  - mnemo: [ MULA ]
    seq:
      - xde_ral, w_setw             # SRC = XDE
      - src_rmux, ld0_opnd, xhl_ral
      - da_ld, dst_rmux, ld0_opnd   # DST = XHL
      - da_ea, vs_fetch, waitmem
      - inc_pc, da_ld, ld0_opnd     # OP0 = (XDE). Leave the inc_pc here to optimize mem access
      - da_ea, vs_fetch, waitmem
      - ld1_opnd, q_setw            # OP1 = (XHL)
      - muls_alu, dst_ld, ${cc}_cc, w_setw
      - spd_rmux, ld1_opnd, dst_rmux
      - dst_rmux, ld0_opnd
      - sub_alu, dst_ld, waitmem, q_fetch
      - ni
  # To do:
  - mnemo: [ SWI, RETI ]
    seq:
      - halt
